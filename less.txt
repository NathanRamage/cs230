BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
BASH_LINENO=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="4" [1]="3" [2]="11" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='4.3.11(1)-release'
COLUMNS=120
DIRSTACK=()
EUID=1021
GROUPS=()
HISTCONTROL=ignoreboth
HISTFILE=/home/cs20176063/.bash_history
HISTFILESIZE=2000
HISTSIZE=1000
HOME=/home/cs20176063
HOSTNAME=canis01
HOSTTYPE=x86_64
IFS=$' \t\n'
LANG=en_US.UTF-8
LC_ALL=C
LD_LIBRARY_PATH=/usr/local/cuda/lib64:
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=30
LOGNAME=cs20176063
LSF_ENVDIR=/opt/openlava-3.0/etc
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:'
MACHTYPE=x86_64-pc-linux-gnu
MAIL=/var/mail/cs20176063
MAILCHECK=60
MANPATH=:/opt/openlava-3.0/share/man:/opt/openlava-3.0/share/man
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/usr/local/cuda/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/opt/openlava-3.0/bin:/opt/openlava-3.0/bin:/share/bin
PIPESTATUS=([0]="1" [1]="0")
PPID=28501
PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
PS2='> '
PS4='+ '
PWD=/home/cs20176063
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
SSH_CLIENT='143.248.164.159 64430 22'
SSH_CONNECTION='143.248.164.159 64430 143.248.188.88 22'
SSH_TTY=/dev/pts/29
TERM=xterm-256color
UID=1021
USER=cs20176063
XDG_RUNTIME_DIR=/run/user/1021
XDG_SESSION_ID=167
_=
__git_printf_supports_v=yes
__grub_script_check_program=grub-script-check
__mvnall_plugin_and_goals=$'clean:clean\n\t clean:help\n\t compiler:compile\n\t compiler:testCompile\n\t compiler:help\n\t deploy:deploy\n\t deploy:deploy-file\n\t deploy:help\n\t install:install\n\t install:install-file\n\t install:help\n\t resources:resources\n\t resources:testResources\n\t resources:copy-resources\n\t resources:help\n\t site:site\n\t site:deploy\n\t site:run\n\t site:stage\n\t site:stage-deploy\n\t site:attach-descriptor\n\t site:jar\n\t site:help\n\t surefire:test\n\t surefire:help\n\t verifier:verify\n\t verifier:help ear:ear\n\t ear:generate-application-xml\n\t ear:help\n\t jar:jar\n\t jar:test-jar\n\t jar:sign\n\t jar:sign-verify\n\t jar:help\n\t rar:rar\n\t rar:help\n\t war:war\n\t war:exploded\n\t war:inplace\n\t war:manifest\n\t war:help\n\t shade:shade\n\t shade:help changelog:changelog\n\t changelog:dev-activity\n\t changelog:file-activity\n\t changelog:help\n\t changes:announcement-mail\n\t changes:announcement-generate\n\t changes:changes-report\n\t changes:jira-report\n\t changes:changes-validate\n\t changes:help\n\t checkstyle:checkstyle\n\t checkstyle:check\n\t checkstyle:help\n\t doap:generate\n\t doap:help\n\t docck:check\n\t docck:help\n\t javadoc:javadoc\n\t javadoc:test-javadoc\n\t javadoc:aggregate\n\t javadoc:test-aggregate\n\t javadoc:jar\n\t javadoc:test-jar\n\t javadoc:help\n\t jxr:jxr\n\t jxr:test-jxr\n\t jxr:help\n\t pmd:pmd\n\t pmd:cpd\n\t pmd:check\n\t pmd:cpd-check\n\t pmd:help\n\t project-info-reports:cim\n\t project-info-reports:dependencies\n\t project-info-reports:dependency-convergence\n\t project-info-reports:dependency-management\n\t project-info-reports:index\n\t project-info-reports:issue-tracking\n\t project-info-reports:license\n\t project-info-reports:mailing-list\n\t project-info-reports:plugin-management\n\t project-info-reports:project-team\n\t project-info-reports:scm\n\t project-info-reports:summary\n\t project-info-reports:help\n\t surefire-report:report\n\t surefire-report:report-only\n\t surefire-report:help ant:ant\n\t ant:clean\n\t ant:help\n\t antrun:run\n\t antrun:help\n\t archetype:create\n\t archetype:generate\n\t archetype:create-from-project\n\t archetype:crawl\n\t archetype:help\n\t assembly:assembly\n\t assembly:directory\n\t assembly:directory-single\n\t assembly:single\n\t assembly:help\n\t dependency:copy\n\t dependency:copy-dependencies\n\t dependency:unpack\n\t dependency:unpack-dependencies\n\t dependency:resolve\n\t dependency:list\n\t dependency:sources\n\t dependency:resolve-plugins\n\t dependency:go-offline\n\t dependency:purge-local-repository\n\t dependency:build-classpath\n\t dependency:analyze\n\t dependency:analyze-dep-mgt\n\t dependency:tree\n\t dependency:help\n\t enforcer:enforce\n\t enforcer:display-info\n\t enforcer:help\n\t gpg:sign\n\t gpg:sign-and-deploy-file\n\t gpg:help\n\t help:active-profiles\n\t help:all-profiles\n\t help:describe\n\t help:effective-pom\n\t help:effective-settings\n\t help:evaluate\n\t help:expressions\n\t help:system\n\t invoker:install\n\t invoker:run\n\t invoker:help\n\t one:convert\n\t one:deploy-maven-one-repository\n\t one:install-maven-one-repository\n\t one:maven-one-plugin\n\t one:help\n\t patch:apply\n\t patch:help\n\t pdf:pdf\n\t pdf:help\n\t plugin:descriptor\n\t plugin:report\n\t plugin:updateRegistry\n\t plugin:xdoc\n\t plugin:addPluginArtifactMetadata\n\t plugin:helpmojo\n\t plugin:help\n\t release:clean\n\t release:prepare\n\t release:rollback\n\t release:perform\n\t release:stage\n\t release:branch\n\t release:help\n\t reactor:resume\n\t reactor:make\n\t reactor:make-dependents\n\t reactor:make-scm-changes\n\t reactor:help\n\t remote-resources:bundle\n\t remote-resources:process\n\t remote-resources:help\n\t repository:bundle-create\n\t repository:bundle-pack\n\t repository:help\n\t scm:branch\n\t scm:validate\n\t scm:add\n\t scm:unedit\n\t scm:export\n\t scm:bootstrap\n\t scm:changelog\n\t scm:list\n\t scm:checkin\n\t scm:checkout\n\t scm:status\n\t scm:update\n\t scm:diff\n\t scm:update-subprojects\n\t scm:edit\n\t scm:tag\n\t scm:help\n\t source:aggregate\n\t source:jar\n\t source:test-jar\n\t source:jar-no-fork\n\t source:test-jar-no-fork\n\t source:help\n\t stage:copy\n\t stage:help \n  eclipse:clean\n\t eclipse:configure-workspace\n\t eclipse:eclipse\n\t eclipse:help\n\t eclipse:install-plugins\n\t eclipse:m2eclipse\n\t eclipse:make-artifacts\n\t eclipse:myeclipse\n\t eclipse:myeclipse-clean\n\t eclipse:rad\n\t eclipse:rad-clean\n\t eclipse:remove-cache\n\t eclipse:to-maven\n\t idea:clean\n\t idea:help\n\t idea:idea\n\t idea:module\n\t idea:project\n\t idea:workspace \n\t plexus:app plexus:bundle-application plexus:bundle-runtime plexus:descriptor plexus:runtime plexus:service\n\t jetty:run-war jetty:run\n\t cargo:start cargo:stop\n\t dbunit:export dbunit:operation\n\t hibernate3:hbm2cfgxml hibernate3:hbm2ddl hibernate3:hbm2doc hibernate3:hbm2hbmxml hibernate3:hbm2java hibernate3:schema-export\n\t   hibernate3:schema-update\n\t groovy:compile groovy:console groovy:execute groovy:generateStubs groovy:generateTestStubs groovy:help groovy:providers groovy:shell\n\t   groovy:testCompile\n\t gwt:compile gwt:eclipse gwt:eclipseTest gwt:generateAsync gwt:help gwt:i18n gwt:test\n\t javacc:help javacc:javacc javacc:jjdoc javacc:jjtree javacc:jjtree-javacc javacc:jtb javacc:jtb-javacc\n\t jboss:configure jboss:deploy jboss:harddeploy jboss:start jboss:stop jboss:undeploy\n\t jboss-packaging:esb jboss-packaging:esb-exploded jboss-packaging:har jboss-packaging:har-exploded jboss-packaging:sar jboss-packaging:sar-exploded\n\t   jboss-packaging:sar-inplace jboss-packaging:spring\n\t jpox:enhance jpox:schema-create jpox:schema-dbinfo jpox:schema-delete jpox:schema-info jpox:schema-validate\n\t make:autoreconf make:chmod make:chown make:compile make:configure make:help make:make-clean make:make-dist make:make-install make:test\n\t   make:validate-pom\n\t nbm:autoupdate nbm:branding nbm:cluster nbm:directory nbm:jar nbm:nbm nbm:populate-repository nbm:run-ide nbm:run-platform\n\t tomcat:deploy tomcat:exploded tomcat:info tomcat:inplace tomcat:list tomcat:redeploy tomcat:resources tomcat:roles tomcat:run tomcat:run-war\n\t   tomcat:sessions tomcat:start tomcat:stop tomcat:undeploy\n\t wagon:copy wagon:download wagon:download-single wagon:help wagon:list wagon:merge-maven-repos wagon:upload wagon:upload-single\n\t was6:clean was6:ejbdeploy was6:help was6:installApp was6:wsAdmin was6:wsDefaultBindings was6:wsListApps was6:wsStartApp was6:wsStartServer\n\t   was6:wsStopApp was6:wsStopServer was6:wsUninstallApp\n\t weblogic:appc weblogic:clientgen weblogic:clientgen9 weblogic:deploy weblogic:jwsc weblogic:listapps weblogic:redeploy weblogic:servicegen\n\t   weblogic:start weblogic:stop weblogic:undeploy weblogic:wsdlgen '
__mvnclassifiers='sources test-jar'
__mvnclean_phases=$'pre-clean\n\t clean\n\t post-clean'
__mvncore_plugins=$'clean:clean\n\t clean:help\n\t compiler:compile\n\t compiler:testCompile\n\t compiler:help\n\t deploy:deploy\n\t deploy:deploy-file\n\t deploy:help\n\t install:install\n\t install:install-file\n\t install:help\n\t resources:resources\n\t resources:testResources\n\t resources:copy-resources\n\t resources:help\n\t site:site\n\t site:deploy\n\t site:run\n\t site:stage\n\t site:stage-deploy\n\t site:attach-descriptor\n\t site:jar\n\t site:help\n\t surefire:test\n\t surefire:help\n\t verifier:verify\n\t verifier:help'
__mvncustom_plugins=
__mvndefault_phases=$'validate \n\t initialize \n\t generate-sources \n\t process-sources \n\t generate-resources \n\t process-resources \n\t compile \n\t process-classes \n\t generate-test-sources \n\t process-test-sources \n\t generate-test-resources \n\t process-test-resources \n\t test-compile \n\t process-test-classes \n\t test \n\t package \n\t pre-integration-test \n\t integration-test \n\t post-integration-test \n\t verify \n\t install \n\t deploy'
__mvnide_plugins=$'eclipse:clean\n\t eclipse:configure-workspace\n\t eclipse:eclipse\n\t eclipse:help\n\t eclipse:install-plugins\n\t eclipse:m2eclipse\n\t eclipse:make-artifacts\n\t eclipse:myeclipse\n\t eclipse:myeclipse-clean\n\t eclipse:rad\n\t eclipse:rad-clean\n\t eclipse:remove-cache\n\t eclipse:to-maven\n\t idea:clean\n\t idea:help\n\t idea:idea\n\t idea:module\n\t idea:project\n\t idea:workspace'
__mvnopts=$'--also-make --also-make-dependents --file --debug --batch-mode --lax-checksums --strict-checksums --check-plugin-updates --define \n  --errors --encrypt-master-password --encrypt-password --fail-at-end --fail-fast --fail-never --help --non-recursive --no-plugin-registry \n  --no-plugin-updates --offline --activate-profiles --projects --quiet --reactor --resume-from --settings --global-settings --update-snapshots \n  --update-plugins --version --show-version'
__mvnoptsWithArg='--file|--define|--encrypt-master-password|--encrypt-password|--resume-from|--settings|--global-settings|--activate-profiles|--projects'
__mvnother_plugins=$'\n\t plexus:app plexus:bundle-application plexus:bundle-runtime plexus:descriptor plexus:runtime plexus:service\n\t jetty:run-war jetty:run\n\t cargo:start cargo:stop\n\t dbunit:export dbunit:operation\n\t hibernate3:hbm2cfgxml hibernate3:hbm2ddl hibernate3:hbm2doc hibernate3:hbm2hbmxml hibernate3:hbm2java hibernate3:schema-export\n\t   hibernate3:schema-update\n\t groovy:compile groovy:console groovy:execute groovy:generateStubs groovy:generateTestStubs groovy:help groovy:providers groovy:shell\n\t   groovy:testCompile\n\t gwt:compile gwt:eclipse gwt:eclipseTest gwt:generateAsync gwt:help gwt:i18n gwt:test\n\t javacc:help javacc:javacc javacc:jjdoc javacc:jjtree javacc:jjtree-javacc javacc:jtb javacc:jtb-javacc\n\t jboss:configure jboss:deploy jboss:harddeploy jboss:start jboss:stop jboss:undeploy\n\t jboss-packaging:esb jboss-packaging:esb-exploded jboss-packaging:har jboss-packaging:har-exploded jboss-packaging:sar jboss-packaging:sar-exploded\n\t   jboss-packaging:sar-inplace jboss-packaging:spring\n\t jpox:enhance jpox:schema-create jpox:schema-dbinfo jpox:schema-delete jpox:schema-info jpox:schema-validate\n\t make:autoreconf make:chmod make:chown make:compile make:configure make:help make:make-clean make:make-dist make:make-install make:test\n\t   make:validate-pom\n\t nbm:autoupdate nbm:branding nbm:cluster nbm:directory nbm:jar nbm:nbm nbm:populate-repository nbm:run-ide nbm:run-platform\n\t tomcat:deploy tomcat:exploded tomcat:info tomcat:inplace tomcat:list tomcat:redeploy tomcat:resources tomcat:roles tomcat:run tomcat:run-war\n\t   tomcat:sessions tomcat:start tomcat:stop tomcat:undeploy\n\t wagon:copy wagon:download wagon:download-single wagon:help wagon:list wagon:merge-maven-repos wagon:upload wagon:upload-single\n\t was6:clean was6:ejbdeploy was6:help was6:installApp was6:wsAdmin was6:wsDefaultBindings was6:wsListApps was6:wsStartApp was6:wsStartServer\n\t   was6:wsStopApp was6:wsStopServer was6:wsUninstallApp\n\t weblogic:appc weblogic:clientgen weblogic:clientgen9 weblogic:deploy weblogic:jwsc weblogic:listapps weblogic:redeploy weblogic:servicegen\n\t   weblogic:start weblogic:stop weblogic:undeploy weblogic:wsdlgen'
__mvnpackaging='pom jar maven-plugin ejb war ear rar par'
__mvnpackaging_plugins=$'ear:ear\n\t ear:generate-application-xml\n\t ear:help\n\t jar:jar\n\t jar:test-jar\n\t jar:sign\n\t jar:sign-verify\n\t jar:help\n\t rar:rar\n\t rar:help\n\t war:war\n\t war:exploded\n\t war:inplace\n\t war:manifest\n\t war:help\n\t shade:shade\n\t shade:help'
__mvnparams=$'-Dmaven.test.skip=true -Dsurefire.useFile=false -Dmaven.surefire.debug -Xdebug -Xnoagent -Djava.compiler=NONE \n  -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y -Dverbose -Dmaven.test.failure.ignore=true'
__mvnphases=$'validate \n\t initialize \n\t generate-sources \n\t process-sources \n\t generate-resources \n\t process-resources \n\t compile \n\t process-classes \n\t generate-test-sources \n\t process-test-sources \n\t generate-test-resources \n\t process-test-resources \n\t test-compile \n\t process-test-classes \n\t test \n\t package \n\t pre-integration-test \n\t integration-test \n\t post-integration-test \n\t verify \n\t install \n\t deploy pre-clean\n\t clean\n\t post-clean pre-site\n\t site\n\t post-site\n\t site-deploy'
__mvnplugins=$'\n ant:\n antrun:\n archetype:\n aembly:\n cargo:\n changelog:\n change:\n checktyle:\n clean:\n compiler:\n dbunit:\n dependency:\n deploy:\n doap:\n docck:\n ear:\n eclipe:\n enforcer:\n gpg:\n groovy:\n gwt:\n help:\n hibernate3:\n idea:\n intall:\n invoker:\n jar:\n javacc:\n javadoc:\n jbo-packaging:\n jbo:\n jetty:\n jpox:\n jxr:\n make:\n nbm:\n one:\n patch:\n pdf:\n plexu:\n plugin:\n pmd:\n project-info-report:\n rar:\n reactor:\n releae:\n remote-reource:\n repoitory:\n reource:\n cm:\n hade:\n ite:\n ource:\n tage:\n urefire-report:\n urefire:\n tomcat:\n verifier:\n wagon:\n war:\n wa6:\n weblogic:\nclean:'
__mvnreporting_plugins=$'changelog:changelog\n\t changelog:dev-activity\n\t changelog:file-activity\n\t changelog:help\n\t changes:announcement-mail\n\t changes:announcement-generate\n\t changes:changes-report\n\t changes:jira-report\n\t changes:changes-validate\n\t changes:help\n\t checkstyle:checkstyle\n\t checkstyle:check\n\t checkstyle:help\n\t doap:generate\n\t doap:help\n\t docck:check\n\t docck:help\n\t javadoc:javadoc\n\t javadoc:test-javadoc\n\t javadoc:aggregate\n\t javadoc:test-aggregate\n\t javadoc:jar\n\t javadoc:test-jar\n\t javadoc:help\n\t jxr:jxr\n\t jxr:test-jxr\n\t jxr:help\n\t pmd:pmd\n\t pmd:cpd\n\t pmd:check\n\t pmd:cpd-check\n\t pmd:help\n\t project-info-reports:cim\n\t project-info-reports:dependencies\n\t project-info-reports:dependency-convergence\n\t project-info-reports:dependency-management\n\t project-info-reports:index\n\t project-info-reports:issue-tracking\n\t project-info-reports:license\n\t project-info-reports:mailing-list\n\t project-info-reports:plugin-management\n\t project-info-reports:project-team\n\t project-info-reports:scm\n\t project-info-reports:summary\n\t project-info-reports:help\n\t surefire-report:report\n\t surefire-report:report-only\n\t surefire-report:help'
__mvnsite_phases=$'pre-site\n\t site\n\t post-site\n\t site-deploy'
__mvntools_plugins=$'ant:ant\n\t ant:clean\n\t ant:help\n\t antrun:run\n\t antrun:help\n\t archetype:create\n\t archetype:generate\n\t archetype:create-from-project\n\t archetype:crawl\n\t archetype:help\n\t assembly:assembly\n\t assembly:directory\n\t assembly:directory-single\n\t assembly:single\n\t assembly:help\n\t dependency:copy\n\t dependency:copy-dependencies\n\t dependency:unpack\n\t dependency:unpack-dependencies\n\t dependency:resolve\n\t dependency:list\n\t dependency:sources\n\t dependency:resolve-plugins\n\t dependency:go-offline\n\t dependency:purge-local-repository\n\t dependency:build-classpath\n\t dependency:analyze\n\t dependency:analyze-dep-mgt\n\t dependency:tree\n\t dependency:help\n\t enforcer:enforce\n\t enforcer:display-info\n\t enforcer:help\n\t gpg:sign\n\t gpg:sign-and-deploy-file\n\t gpg:help\n\t help:active-profiles\n\t help:all-profiles\n\t help:describe\n\t help:effective-pom\n\t help:effective-settings\n\t help:evaluate\n\t help:expressions\n\t help:system\n\t invoker:install\n\t invoker:run\n\t invoker:help\n\t one:convert\n\t one:deploy-maven-one-repository\n\t one:install-maven-one-repository\n\t one:maven-one-plugin\n\t one:help\n\t patch:apply\n\t patch:help\n\t pdf:pdf\n\t pdf:help\n\t plugin:descriptor\n\t plugin:report\n\t plugin:updateRegistry\n\t plugin:xdoc\n\t plugin:addPluginArtifactMetadata\n\t plugin:helpmojo\n\t plugin:help\n\t release:clean\n\t release:prepare\n\t release:rollback\n\t release:perform\n\t release:stage\n\t release:branch\n\t release:help\n\t reactor:resume\n\t reactor:make\n\t reactor:make-dependents\n\t reactor:make-scm-changes\n\t reactor:help\n\t remote-resources:bundle\n\t remote-resources:process\n\t remote-resources:help\n\t repository:bundle-create\n\t repository:bundle-pack\n\t repository:help\n\t scm:branch\n\t scm:validate\n\t scm:add\n\t scm:unedit\n\t scm:export\n\t scm:bootstrap\n\t scm:changelog\n\t scm:list\n\t scm:checkin\n\t scm:checkout\n\t scm:status\n\t scm:update\n\t scm:diff\n\t scm:update-subprojects\n\t scm:edit\n\t scm:tag\n\t scm:help\n\t source:aggregate\n\t source:jar\n\t source:test-jar\n\t source:jar-no-fork\n\t source:test-jar-no-fork\n\t source:help\n\t stage:copy\n\t stage:help'
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_xspecs=([freeamp]="!*.@(mp3|og[ag]|pls|m3u)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [bibtex]="!*.aux" [rgview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm)" [chromium-browser]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [makeinfo]="!*.texi*" [kwrite]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [lrunzip]="!*.lrz" [bzcat]="!*.?(t)bz?(2)" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [rpm2cpio]="!*.[rs]pm" [view]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [ly2dvi]="!*.ly" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [lzgrep]="!*.@(tlz|lzma)" [pyflakes]="!*.py" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [dvipdfmx]="!*.dvi" [advi]="!*.dvi" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [lzmore]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [poedit]="!*.po" [firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [madplay]="!*.mp3" [lbzcat]="!*.?(t)bz?(2)" [lilypond]="!*.ly" [gtranslator]="!*.po" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [sxemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [epdfview]="!*.pdf" [gpdf]="!*.[pf]df" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [pbzcat]="!*.?(t)bz?(2)" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [lzcat]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [vim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ps2pdf14]="!*.@(?(e)ps|pdf)" [dvips]="!*.dvi" [lzfgrep]="!*.@(tlz|lzma)" [hbrun]="!*.[Hh][Rr][Bb]" [kbabel]="!*.po" [rview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [xv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [rgvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvitype]="!*.dvi" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [playmidi]="!*.@(mid?(i)|cmf)" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [xpdf]="!*.@(pdf|fdf)?(.@(gz|xz|Z|bz2))" [gqmpeg]="!*.@(mp3|og[ag]|pls|m3u)" [lzegrep]="!*.@(tlz|lzma)" [aviplay]="!*.@(avi|asf|wmv)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [bunzip2]="!*.?(t)bz?(2)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [znew]="*.Z" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lokalize]="!*.po" [kate]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [unlzma]="!*.@(tlz|lzma)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [vi]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [mozilla-firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [gvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [uncompress]="!*.Z" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [unpigz]="!*.@(Z|[gGd]z|t[ag]z)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [emacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ps2pdf]="!*.@(?(e)ps|pdf)" [kpdf]="!*.@(?(e)ps|pdf)" [oomath]="!*.@(sxm|smf|mml|odf)" [compress]="*.Z" [iceweasel]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [mpg321]="!*.mp3" [mpg123]="!*.mp3" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [unzip]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [pbunzip2]="!*.?(t)bz?(2)" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [dvipdf]="!*.dvi" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [dvipdfm]="!*.dvi" [oobase]="!*.odb" [texi2html]="!*.texi*" [zipinfo]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [google-chrome]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2)))" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [bzme]="!*.@(zip|z|gz|tgz)" [xfig]="!*.fig" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [dviselect]="!*.dvi" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" )
__all_modules () 
{ 
    while read name; do
        name=${name%% *};
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-modules 2> /dev/null)
}
__cards () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list cards short 2> /dev/null)
}
__expand_tilde_by_ref () 
{ 
    if [[ ${!1} == \~* ]]; then
        if [[ ${!1} == */* ]]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i ))
        do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                cur="${cur:1}";
                ((index--));
            done;
            if [[ $i -lt $cword ]]; then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                index=$(( index - old_size + new_size ));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ $index -lt 0 ]] && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
}
__git_ps1 () 
{ 
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return
        ;;
    esac;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        if [ $pcmode = yes ]; then
            PS1="$ps1pc_start$ps1pc_end";
        fi;
        return;
    fi;
    local short_sha;
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        read b 2> /dev/null < "$g/rebase-merge/head-name";
        read step 2> /dev/null < "$g/rebase-merge/msgnum";
        read total 2> /dev/null < "$g/rebase-merge/end";
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            read step 2> /dev/null < "$g/rebase-apply/next";
            read total 2> /dev/null < "$g/rebase-apply/last";
            if [ -f "$g/rebase-apply/rebasing" ]; then
                read b 2> /dev/null < "$g/rebase-apply/head-name";
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                    r="|CHERRY-PICKING";
                else
                    if [ -f "$g/REVERT_HEAD" ]; then
                        r="|REVERTING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! read head 2> /dev/null < "$g/HEAD"; then
                    if [ $pcmode = yes ]; then
                        PS1="$ps1pc_start$ps1pc_end";
                    fi;
                    return;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet --exit-code || w="*";
                if [ -n "$short_sha" ]; then
                    git diff-index --cached --quiet HEAD -- || i="+";
                else
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && [ -r "$g/refs/stash" ]; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --error-unmatch -- '*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    local f="$w$i$s$u";
    local gitstring="$c${b##refs/heads/}${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi
}
__git_ps1_colorize_gitstring () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            p="$p $(git rev-parse --abbrev-ref "$upstream" 2>/dev/null)";
        fi;
    fi
}
__grub_dir () 
{ 
    local i c=1 boot_dir;
    for ((c=1; c <= ${#COMP_WORDS[@]}; c++ ))
    do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            --boot-directory)
                c=$((++c));
                i="${COMP_WORDS[c]}";
                boot_dir="${i##*=}";
                break
            ;;
        esac;
    done;
    boot_dir=${boot_dir-/boot};
    echo "${boot_dir%/}/grub"
}
__grub_get_last_option () 
{ 
    local i;
    for ((i=$COMP_CWORD-1; i > 0; i-- ))
    do
        if [[ "${COMP_WORDS[i]}" == -* ]]; then
            echo "${COMP_WORDS[i]}";
            break;
        fi;
    done
}
__grub_get_options_from_help () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --help);
    do
        case $i in 
            --*)
                echo "${i%=*}"
            ;;
        esac;
    done
}
__grub_get_options_from_usage () 
{ 
    local prog;
    if [ $# -ge 1 ]; then
        prog="$1";
    else
        prog="${COMP_WORDS[0]}";
    fi;
    local i IFS=" "'	''
';
    for i in $(LC_ALL=C $prog --usage);
    do
        case $i in 
            \[--*\])
                i=${i#[};
                echo ${i%%?(=*)]}
            ;;
        esac;
    done
}
__grub_list_menuentries () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local config_file=$(__grub_dir)/grub.cfg;
    if [ -f "$config_file" ]; then
        local IFS='
';
        COMPREPLY=($(compgen             -W "$( awk -F "[\"']" '/menuentry/ { print $2 }' $config_file )"             -- "$cur" ));
    fi
}
__grub_list_modules () 
{ 
    local grub_dir=$(__grub_dir);
    local IFS='
';
    COMPREPLY=($( compgen -f -X '!*/*.mod' -- "${grub_dir}/$cur" | {
         while read -r tmp; do
             [ -n $tmp ] && {
                 tmp=${tmp##*/}
                 printf '%s\n' ${tmp%.mod}
             }
         done
         }
        ))
}
__grubcomp () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        --*=)
            COMPREPLY=()
        ;;
        *)
            local IFS=' ''	''
';
            COMPREPLY=($(compgen -P "${2-}" -W "${1-}" -S "${4-}" -- "$cur"))
        ;;
    esac
}
__loaded_modules () 
{ 
    while IFS='	' read idx name _; do
        printf "%s %s\n" "$idx" "$name";
    done < <(pactl list modules short 2> /dev/null)
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while [[ $((--i)) -ge 0 ]]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__mvnarchetype_generate () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "archetypeArtifactId= archetypeCatalog= archetypeGroupId= archetypeRepository= archetypeVersion= basedir= goals= interactiveMode=" "-D" "${cur}"
}
__mvncomp () 
{ 
    local genOpt=;
    if [ "$1" == "-nospace" ]; then
        genOpt="true";
        shift;
    fi;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        -*=)
            COMPREPLY=()
        ;;
        *)
            local IFS='
';
            COMPREPLY=($(compgen -P "$2" 			-W "$(__mvncomp_1 "$1" "$4")" 			-- "$cur"))
        ;;
    esac
}
__mvncomp_1 () 
{ 
    local c IFS=' ''	''
';
    for c in $1;
    do
        case "$c$2" in 
            --*=*)
                printf %s'
' "$c$2"
            ;;
            *.)
                printf %s'
' "$c$2"
            ;;
            *)
                printf %s'
' "$c$2 "
            ;;
        esac;
    done
}
__mvndependency_analyze () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "ignoreNonCompile=true outputXML=true scriptableFlag= scriptableOutput=true verbose=true" "-D" "${cur}"
}
__mvndependency_analyze_dep_mgt () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "ignoreDirect=false" "-D" "${cur}"
}
__mvndependency_purge_local_repository () 
{ 
    local fuzziness="file version artifactId groupId";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        resolutionFuzziness=*)
            __mvncomp "${fuzziness}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "actTransitively=false exclude= reResolve=false verbose=true
			$(__mvnlist_prefix 'resolutionFuzziness=' ${fuzziness})";
            "-D" "${cur}"
        ;;
    esac
}
__mvndependency_resolve () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        classifier=*)
            __mvncomp "${__mvnclassifiers}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "$(__mvnlist_prefix 'classifier=' ${__mvnclassifiers}) excludeArtifactIds= excludeClassifiers= excludeGroupIds=
			excludeScope= excludeTransitive=true excludeTypes= includeArtifactIds= includeClassifiers= includeGroupIds= includeScope= 
			includeTypes= markersDirectory= outputAbsoluteArtifactFilename= outputFile= outputScope=false overWriteIfNewer=false
			overWriteReleases=true overWriteSnapshots=true silent=true type=";
            "-D" "${cur}"
        ;;
    esac
}
__mvndependency_tree () 
{ 
    local tokens="whitespace standard extended";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        tokens=*)
            __mvncomp "${tokens}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "excludes= includes= outputFile= scope= verbose=true
			$(__mvnlist_prefix 'tokens=' ${tokens})";
            "-D" "${cur}"
        ;;
    esac
}
__mvndependency_x_dependencies () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        classifier=*)
            __mvncomp "${__mvnclassifiers}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "$(__mvnlist_prefix 'classifier=' ${__mvnclassifiers})" "-D" "${cur}"
        ;;
    esac
}
__mvndeploy_deploy () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "altDeploymentRepository= skip=true updateReleaseInfo=true" "-D" "${cur}"
}
__mvndeploy_deploy_file () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        file=*)
            COMPREPLY=($( compgen -f -P "$(__mvnprefix_equals $cur)" -- "${cur#*=}" ))
        ;;
        pomFile=*)
            __mvncomp "$(__mvnlist_poms)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        packaging=*)
            __mvncomp "${__mvnpackaging}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            local options="artifactId= classifier= description= file=press file=tab generatePom=true groupId= pomFile=press pomFile=tab repositoryId= 
		  repositoryLayout=legacy uniqueVersion=false url= version=";
            options="$options $(__mvnlist_prefix 'packaging=' ${__mvnpackaging} )";
            __mvncomp "$options" "-D" "${cur}"
        ;;
    esac
}
__mvnhelp_describe () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        cmd=*:*)
            local plugin="${cur#*=}";
            plugin="${plugin%%:*}:";
            __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_colon $cur)" "${cur#*:}"
        ;;
        cmd=*)
            __mvncomp "${__mvnphases} ${__mvnall_plugin_and_goals}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        plugin=*)
            __mvncomp "org.apache.maven.plugins:maven-" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        groupId=*)
            __mvncomp "org.apache.maven.plugins" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        artifactId=*)
            __mvncomp "" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "detail cmd=press cmd=tab plugin= groupId= artifactId=" "-D" "${cur}"
        ;;
    esac
}
__mvninstall_install_file () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        file=*)
            COMPREPLY=($( compgen -f -P "$(__mvnprefix_equals $cur)" -- "${cur#*=}" ))
        ;;
        pomFile=*)
            __mvncomp "$(__mvnlist_poms)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        sources=*)
            __mvncomp "$(__mvnlist_jars)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        javadoc=*)
            __mvncomp "$(__mvnlist_jars)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        packaging=*)
            __mvncomp "${__mvnpackaging}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            local options="artifactId= classifier= file=press file=tab generatePom=true groupId= pomFile=press pomFile=tab
		  createChecksum=true url= version= sources=press sources=tab javadoc=press javadoc=tab";
            options="$options $(__mvnlist_prefix 'packaging=' ${__mvnpackaging} )";
            __mvncomp "$options" "-D" "${cur}"
        ;;
    esac
}
__mvnlist_goals () 
{ 
    local plugin=$1;
    local pfx="";
    if [[ -n "$2" ]]; then
        pfx=$2;
    fi;
    echo ${__mvnall_plugin_and_goals} | tr ' ' '\n' | grep --color=auto "$plugin" | sed "s/.*:/${pfx}/g"
}
__mvnlist_jars () 
{ 
    for x in `find -type f -name *.jar`;
    do
        echo ${x#./};
    done
}
__mvnlist_poms () 
{ 
    for x in `find -type f -name pom.xml -or -name *.pom`;
    do
        echo ${x#./};
    done
}
__mvnlist_prefix () 
{ 
    local pfx=$1 IFS=' ''	''
';
    shift;
    local list=$@;
    for c in $list;
    do
        echo "$pfx$c";
    done
}
__mvnlist_projects () 
{ 
    local poms=$(find . -name pom.xml -print);
    echo $poms | while read -d ' ' POM; do
        local DIR=$(dirname "$POM");
        if [[ "$DIR" != "." ]]; then
            echo "${DIR#./}";
        fi;
    done
}
__mvnplugin_help () 
{ 
    local plugin=$1;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        goal=*)
            __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "detail lineLength= indentSize= $(__mvnlist_goals $plugin 'goal=')" "-D" "${cur}"
        ;;
    esac
}
__mvnprefix_colon () 
{ 
    local cur=$1;
    local pfx="";
    case "$COMP_WORDBREAKS" in 
        *:*)
            : great
        ;;
        *)
            pfx="${cur%%:*}:"
        ;;
    esac;
    echo $pfx
}
__mvnprefix_comma () 
{ 
    local cur=$1;
    local pfx="";
    case "$COMP_WORDBREAKS" in 
        *,*)
            : great
        ;;
        *)
            pfx="${cur%%,*},"
        ;;
    esac;
    echo $pfx
}
__mvnprefix_equals () 
{ 
    local cur=$1;
    local pfx="";
    case "$COMP_WORDBREAKS" in 
        *=*)
            : great
        ;;
        *)
            pfx="${cur%%=*}="
        ;;
    esac;
    echo $pfx
}
__mvnrelease_prepare () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "username= dryRun=true" "-D" "${cur}"
}
__mvnscm_checkin () 
{ 
    local versionType="branch tag revision";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        scmVersionType=*)
            __mvncomp "${versionType}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "username= message= passphrase= password= scmVersion= $(__mvnlist_prefix 'scmVersionType=' ${versionType})" "-D" "${cur}"
        ;;
    esac
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    for i in $1;
    do
        case $i in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__ports () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tPorts:/ {
            flag=1; next
         }

         /^\t[A-Za-z]/ {
             flag=0
         }

         flag {
             if (/^\t\t[A-Za-z]/)
                 ports = ports substr($0, 3, index($0, ":")-3) " "
         }

         END {
             print ports
         }'
}
__profiles () 
{ 
    pactl list cards 2> /dev/null | awk -e '/^\tProfiles:/ {
            flag=1; next
        }

        /^\t[A-Za-z]/ {
            flag=0
        }

        flag {
            if (/^\t\t[A-Za-z]/)
                profiles = profiles substr($0, 3, index($0, ": ")-3) " "
        }

        END {
            print profiles
        }'
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
                [[ $line != [' 	']* ]] && (( j >= 2 )) && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [[ $i == $COMP_CWORD ]] && eval $3=$j;
                line=${line#*"${COMP_WORDS[$i]}"};
                [[ $line == [' 	']* ]] && ((j++));
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            line=${line#*"${COMP_WORDS[i]}"};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
        [[ $i == $COMP_CWORD ]] && eval $3=$j;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
__resample_methods () 
{ 
    while read name; do
        printf "%s\n" "$name";
    done < <(pulseaudio --dump-resample-methods 2> /dev/null)
}
__sink_inputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sink-inputs short 2> /dev/null)
}
__sinks () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sinks short 2> /dev/null)
}
__sinks_idx () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list sinks short 2> /dev/null)
}
__source_outputs () 
{ 
    while IFS='	' read idx _ _ _ _; do
        printf "%s\n" "$idx";
    done < <(pactl list source-outputs short 2> /dev/null)
}
__sources () 
{ 
    while IFS='	' read _ name _ _ _; do
        printf "%s\n" "$name";
    done < <(pactl list sources short 2> /dev/null)
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
_apport-bug () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help --save -v --version --tag -w --window';
    case "$prev" in 
        ubuntu-bug | apport-bug)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions="--tag";
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-cli () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
                 -c --crash-file --save -v --version --tag -w --window';
    case "$prev" in 
        apport-cli)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions='--tag';
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--symptom.* || "${COMP_WORDS[*]}" =~ .*\ -s\ .* ]]; then
                dashoptions="-s --symptom $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--update.* || "${COMP_WORDS[*]}" =~ .*\ -u\ .* ]]; then
                dashoptions="-u --update $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--file-bug.* || "${COMP_WORDS[*]}" =~ .*\ -f\ .* ]]; then
                dashoptions="-f --file-bug $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--crash-file.* || "${COMP_WORDS[*]}" =~ .*\ -c\ .* ]]; then
                dashoptions="-c --crash-file $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-collect () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-collect)
            COMPREPLY=($( compgen -W "-p --package --tag" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
        --tag)
            return 0
        ;;
        *)
            if [[ "${COMP_WORDS[*]}" =~ .*\ -p.* || "${COMP_WORDS[*]}" =~ .*--package.* ]]; then
                COMPREPLY=($( compgen -W "--tag" -- $cur));
            else
                COMPREPLY=($( compgen -W "-p --package --tag" -- $cur));
            fi
        ;;
    esac
}
_apport-unpack () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-unpack)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
    esac
}
_apport_parameterless () 
{ 
    local param;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*" )";
    COMPREPLY=($( compgen -W "$param" -- $cur))
}
_apport_symptoms () 
{ 
    local syms;
    if [ -r /usr/share/apport/symptoms ]; then
        for FILE in $(ls /usr/share/apport/symptoms);
        do
            if [[ ! "$FILE" =~ ^_.* && -n $(egrep "^def run\s*\(.*\):" /usr/share/apport/symptoms/$FILE) ]]; then
                syms="$syms ${FILE%.py}";
            fi;
        done;
    fi;
    echo $syms
}
_available_interfaces () 
{ 
    local cmd PATH=$PATH:/sbin;
    if [[ ${1:-} == -w ]]; then
        cmd="iwconfig";
    else
        if [[ ${1:-} == -a ]]; then
            cmd="{ ifconfig || ip link show up; }";
        else
            cmd="{ ifconfig -a || ip link show; }";
        fi;
    fi;
    COMPREPLY=($( eval $cmd 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_axi_cache () 
{ 
    local cur prev cmd;
    COMPREPLY=();
    COMP_WORDBREAKS=${COMP_WORDBREAKS//:};
    type _get_comp_words_by_ref &> /dev/null && { 
        _get_comp_words_by_ref -n: cur prev
    } || { 
        cur=$(_get_cword ":");
        prev=${COMP_WORDS[$COMP_CWORD-1]}
    };
    cmd=${COMP_WORDS[1]};
    case "$prev" in 
        *axi-cache*)
            COMPREPLY=($(compgen -W "help more search show again showpkg showsrc depends rdepends policy madison" -- "$cur"));
            return 0
        ;;
        --sort)
            COMPREPLY=($(compgen -W "$(egrep ^[a-z] /var/lib/apt-xapian-index/values | awk -F"\t" '{print $1}')" -- "$cur"));
            return 0
        ;;
    esac;
    case "$cmd" in 
        search | again)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--sort --tags" -- "$cur"));
                return 0;
            fi
        ;;
        show | showpkg | showsrc | depends | rdepends | policy | madison)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($(compgen -W "--last" -- "$cur"));
                return 0;
            fi
        ;;
        *)
            return 0
        ;;
    esac;
    if [ -n "$cur" ]; then
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=partial)" -- "$cur"));
    else
        COMPREPLY=($(compgen -W "$(${COMP_WORDS[@]} --tabcomplete=plain)" -- "$cur"));
    fi;
    return 0
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
_cmake () 
{ 
    local cur prev words cword split=false;
    _init_completion -n := || return;
    local prefix=;
    if [[ $cur == -D* ]]; then
        prev=-D;
        prefix=-D;
        cur="${cur#-D}";
    else
        if [[ $cur == -U* ]]; then
            prev=-U;
            prefix=-U;
            cur="${cur#-U}";
        fi;
    fi;
    case "$prev" in 
        -D)
            if [[ $cur == *=* ]]; then
                local var type value;
                var="${cur%%[:=]*}";
                value="${cur#*=}";
                if [[ $cur == CMAKE_BUILD_TYPE* ]]; then
                    COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                        MinSizeRel' -- "$value" ));
                    return;
                fi;
                if [[ $cur == *:* ]]; then
                    type="${cur#*:}";
                    type="${type%%=*}";
                else
                    type=$( cmake -LA -N 2>/dev/null | grep "$var:"                         2>/dev/null );
                    type="${type#*:}";
                    type="${type%%=*}";
                fi;
                case "$type" in 
                    FILEPATH)
                        cur="$value";
                        _filedir;
                        return
                    ;;
                    PATH)
                        cur="$value";
                        _filedir -d;
                        return
                    ;;
                    BOOL)
                        COMPREPLY=($( compgen -W 'ON OFF TRUE FALSE' --                             "$value" ));
                        return
                    ;;
                    STRING | INTERNAL)
                        return
                    ;;
                esac;
            else
                if [[ $cur == *:* ]]; then
                    local type="${cur#*:}";
                    COMPREPLY=($( compgen -W 'FILEPATH PATH STRING BOOL INTERNAL'                    -S = -- "$type" ));
                    compopt -o nospace;
                else
                    COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                    cut -f1 -d: )' -P "$prefix" -- "$cur" ));
                    compopt -o nospace;
                fi;
            fi;
            return
        ;;
        -U)
            COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                cut -f1 -d: )' -P "$prefix" -- "$cur" ));
            return
        ;;
    esac;
    _split_longopt && split=true;
    case "$prev" in 
        -C | -P | --graphviz | --system-information)
            _filedir;
            return
        ;;
        --build)
            _filedir -d;
            return
        ;;
        -E)
            COMPREPLY=($( compgen -W "$( cmake -E help |& sed -n                 '/^  /{s|^  \([^ ]\{1,\}\) .*$|\1|;p}' 2>/dev/null )"                 -- "$cur" ));
            return
        ;;
        -G)
            local IFS='
';
            local quoted;
            printf -v quoted %q "$cur";
            COMPREPLY=($( compgen -W '$( cmake --help 2>/dev/null | sed -n \
                -e "1,/^Generators/d" \
                -e "/^  *[^ =]/{s|^ *\([^=]*[^ =]\).*$|\1|;s| |\\\\ |g;p}" \
                2>/dev/null )' -- "$quoted" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cmake --help-command-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-module)
            COMPREPLY=($( compgen -W '$( cmake --help-module-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-policy)
            COMPREPLY=($( compgen -W '$( cmake --help-policies 2>/dev/null |
                grep "^  CMP" 2>/dev/null )' -- "$cur" ));
            return
        ;;
        --help-property)
            COMPREPLY=($( compgen -W '$( cmake --help-property-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cmake --help-variable-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
    esac;
    $split && return;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i=0; i < $word_offset; i++ ))
    do
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        do
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT-=${#COMP_WORDS[i]}));
    done;
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    ((COMP_CWORD -= $word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($( compgen -d -c -- "$cur" ));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$( complete -p $cmd 2>/dev/null );
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$( complete -p ${cmd##*/} 2>/dev/null );
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$( complete -p $compcmd 2>/dev/null );
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($( eval compgen "$cspec" -- '$cur' ));
            fi;
        else
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
                _minimal;
            fi;
        fi;
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_completion_loader () 
{ 
    local compfile=./completions;
    [[ $BASH_SOURCE == */* ]] && compfile="${BASH_SOURCE%/*}/completions";
    compfile+="/${1##*/}";
    [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 124;
    complete -F _minimal "$1" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
_cpack () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -G)
            COMPREPLY=($( compgen -W '$( cpack --help 2>/dev/null |
                sed -e "1,/^Generators/d" -e "s|^ *\([^ ]*\) .*$|\1|" \
                2>/dev/null )' -- "$cur" ));
            return
        ;;
        -C)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -D)
            [[ $cur == *=* ]] && return;
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -S = -- "$cur" ));
            compopt -o nospace;
            return
        ;;
        -P | -R | --vendor)
            return
        ;;
        -B)
            _filedir -d;
            return
        ;;
        --config)
            _filedir;
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cpack --help-command-list 2>/dev/null|
                grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_ctest () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -C | --build-config)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -j | --parallel)
            COMPREPLY=($( compgen -W "{1..$(( $(_ncpus)*2 ))}" -- "$cur" ));
            return
        ;;
        -O | --output-log | -A | --add-notes | --extra-submit)
            _filedir;
            return
        ;;
        -L | --label-regex | -LE | --label-exclude | --track | -I | --tests-information | --max-width | --timeout | --stop-time)
            return
        ;;
        -R | --tests-regex | -E | --exclude-regex)
            COMPREPLY=($( compgen -W '$( ctest -N 2>/dev/null |
                grep "^  Test" 2>/dev/null | cut -d: -f 2 )' -- "$cur" ));
            return
        ;;
        -D | --dashboard)
            if [[ $cur == @(Experimental|Nightly|Continuous)* ]]; then
                local model action;
                action=${cur#@(Experimental|Nightly|Continuous)};
                model=${cur%"$action"};
                COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                    Coverage Submit MemCheck' -P "$model" -- "$action" ));
            else
                COMPREPLY=($( compgen -W 'Experimental Nightly Continuous'                 -- "$cur" ));
                compopt -o nospace;
            fi;
            return
        ;;
        -M | --test-model)
            COMPREPLY=($( compgen -W 'Experimental Nightly Continuous' --                 "$cur" ));
            return
        ;;
        -T | --test-action)
            COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                Coverage Submit MemCheck' -- "$cur" ));
            return
        ;;
        -S | --script | -SP | --script-new-process)
            _filedir '@(cmake|ctest)';
            return
        ;;
        --interactive-debug-mode)
            COMPREPLY=($( compgen -W '0 1' -- "$cur" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( ctest --help-command-list 2>/dev/null|
                grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_debconf_show () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=($( compgen -W '--listowners --listdbs --db=' -- $cur ) $( apt-cache pkgnames -- $cur ))
}
_desktop_file_validate () 
{ 
    COMPRELY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _filedir '@(desktop)'
}
_dkms () 
{ 
    local cur prev command module i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "add autoinstall remove build install uninstall 			match mkdriverdisk mktarball ldtarball mkrpm mkdeb mkdsc mkkmp 			status" -- $cur ));
    else
        prev=${COMP_WORDS[COMP_CWORD-1]};
        command=${COMP_WORDS[1]};
        case $prev in 
            -m)
                if [ "$command" = 'add' ]; then
                    _filename_parts '.*-.*' 1;
                else
                    _subdirectories /var/lib/dkms;
                fi;
                return 0
            ;;
            -v)
                for ((i=1; i < COMP_CWORD; i++ ))
                do
                    if [[ "${COMP_WORDS[i]}" == -m ]]; then
                        module=${COMP_WORDS[i+1]};
                        break;
                    fi;
                done;
                if [ -n "$module" ]; then
                    if [ "$command" = 'add' ]; then
                        _filename_parts "$module-.*" 2;
                    else
                        _subdirectories /var/lib/dkms/$module;
                    fi;
                    return 0;
                fi
            ;;
            -k)
                _kernels;
                return 0
            ;;
            -@\(c | -spec | -archive | -config\))
                _filedir;
                return 0
            ;;
            --kernelsourcedir)
                _filedir -d;
                return 0
            ;;
        esac;
        if [[ "$cur" == -* ]]; then
            case $command in 
                add)
                    options='-c --rpm_safe_upgrade'
                ;;
                remove)
                    options='--rpm_safe_upgrade'
                ;;
                build)
                    options='--config'
                ;;
                mkdriverdisk)
                    options='-d --distro -r --release --size'
                ;;
                ldtarball)
                    options='--archive --force'
                ;;
                mktarball)
                    options='--source-only --binaries-only'
                ;;
                mkrpm)
                    options='--source-only'
                ;;
                mkkmp)
                    options='--spec'
                ;;
                match)
                    options='--templatekernel'
                ;;
            esac;
            options="$options -m -v -k -a --arch -q --quiet -V 				--version --all --no-prepare-kernel 				--no-clean-kernel --kernelsourcedir 				--directive";
            COMPREPLY=($( compgen -W "$options" -- $cur ));
        fi;
    fi
}
_dvd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur 2> /dev/null;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 ]] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_filedir () 
{ 
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted x tmp;
    _quote_readline_by_ref "$cur" quoted;
    x=$( compgen -d -- "$quoted" ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ "$1" != -d ]]; then
        xspec=${1:+"!*.@($1|${1^^})"};
        x=$( compgen -f -X "$xspec" -- $quoted ) && while read -r tmp; do
            toks+=("$tmp");
        done <<< "$x";
    fi;
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && "$1" != -d && ${#toks[@]} -lt 1 ]] && x=$( compgen -f -- $quoted ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return 0;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [[ -n $tmp ]] && printf '%s\n' $tmp
        done
        }
        ));
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_filename_parts () 
{ 
    COMPREPLY=($( command ls -F /usr/src/ 2>/dev/null | grep -E '^'$1'/$' 		| sed -r -e 's/^([^-]+)-(.+)\/$/\'$2'/' | grep "^$cur" ))
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [[ -d /etc/fs ]] && command ls /etc/fs )";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($( compgen -W "$fss" -- "$cur" ))
}
_gem191 () 
{ 
    local cur prev completions;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    COMMANDS='build cert check cleanup contents dependency\
      environment fetch generate_index help install list\
      lock mirror outdated pristine query rdoc search server\
      sources specification uninstall unpack update which';
    GEM_OPTIONS='\
      -h --help\
      -v --version';
    COMMON_OPTIONS='\
      -h --help\
      -V --verbose --no-verbose\
      -q --quiet\
      --config-file\
      --backtrace\
      --debug';
    CERT_OPTIONS='\
      -a -add\
      -l --list\
      -r --remove\
      -b --build\
      -C --certificate\
      -K --private-key\
      -s --sign';
    CHECK_OPTIONS='\
      --verify\
      -a --alien\
      -t --test\
      -v --version';
    CLEANUP_OPTIONS='\
      -d --dry-run';
    CONTENTS_OPTIONS='\
      -v --version\
      -s --spec-dir\
      -l --lib-only --no-lib-only';
    DEPENDENCY_OPTIONS='\
      -v --version\
      --platform\
      -R --reverse-dependencies --no-reverse-dependencies\
      -p --pipe';
    ENVIRONMENT_OPTIONS='';
    FETCH_OPTIONS='\
      -v --version\
      --platform\
      -B --bulk-threshold\
      -p --http-proxy --no-http-proxy\
      --source';
    GENERATE_INDEX_OPTIONS='\
      -d --directory';
    HELP_OPTIONS=$COMMANDS;
    INSTALL_OPTIONS='\
      --platform\
      -v --version\
      -i --install-dir\
      -d --rdoc --no-rdoc\
      --ri --no-ri\
      -E --env-shebang\
      -f --force --no-force\
      -t --test --no-test\
      -w --wrappers --no-wrappers\
      -P --trust-policy\
      --ignore-dependencies\
      -y --include-dependencies\
      --format-executable --no-format-executable\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    LIST_OPTIONS='\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    LOCK_OPTIONS='\
      -s --strict --no-strict';
    MIRROR_OPTIONS='';
    OUTDATED_OPTIONS='\
      --platform';
    PRISTINE_OPTIONS='\
      --all\
      -v --version';
    QUERY_OPTIONS='\
      -n --name-matches\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    RDOC_OPTIONS='\
      --all\
      --rdoc --no-rdoc\
      --ri --no-ri\
      -v --version';
    SEARCH_OPTIONS='\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    SERVER_OPTIONS='\
      -p --port\
      -d --dir\
      --daemon --no-daemon';
    SOURCES_OPTIONS='\
      -a --add\
      -l --list\
      -r --remove\
      -u --update\
      -c --clear-all';
    SPECIFICATION_OPTIONS='\
      -v --version\
      --platform\
      --all\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    UNINSTALL_OPTIONS='\
      -a --all --no-all\
      -i --ignore-dependencies --no-ignore-dependencies\
      -x --executables --no-executables\
      -v --version\
      --platform';
    UNPACK_OPTIONS='\
      --target\
      -v --version';
    UPDATE_OPTIONS='\
      --system\
      --platform\
      -i --install-dir\
      -d --rdoc --no-rdoc\
      --ri --no-ri\
      -E --env-shebang\
      -f --force --no-force\
      -t --test --no-test\
      -w --wrappers --no-wrappers\
      -P --trust-policy\
      --ignore-dependencies\
      -y --include-dependencies\
      --format-executable --no-format-executable\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    WHICH_OPTIONS='\
      -a --all --no-all\
      -g --gems-first --no-gems-first';
    case "${prev}" in 
        build)
            completions="$COMMON_OPTIONS $BUILD_OPTIONS"
        ;;
        cert)
            completions="$COMMON_OPTIONS $CERT_OPTIONS"
        ;;
        check)
            completions="$COMMON_OPTIONS $CHECK_OPTIONS"
        ;;
        cleanup)
            completions="$COMMON_OPTIONS $CLEANUP_OPTIONS"
        ;;
        contents)
            completions="$COMMON_OPTIONS $CONTENTS_OPTIONS"
        ;;
        dependency)
            completions="$COMMON_OPTIONS $DEPENDENCY_OPTIONS"
        ;;
        environment)
            completions="$COMMON_OPTIONS $ENVIRONMENT_OPTIONS"
        ;;
        fetch)
            completions="$COMMON_OPTIONS $FETCH_OPTIONS"
        ;;
        generate_index)
            completions="$COMMON_OPTIONS $GENERATE_INDEX_OPTIONS"
        ;;
        help)
            completions="$COMMON_OPTIONS $HELP_OPTIONS"
        ;;
        install)
            completions="$COMMON_OPTIONS $INSTALL_OPTIONS"
        ;;
        list)
            completions="$COMMON_OPTIONS $LIST_OPTIONS"
        ;;
        lock)
            completions="$COMMON_OPTIONS $LOCK_OPTIONS"
        ;;
        mirror)
            completions="$COMMON_OPTIONS $MIRROR_OPTIONS"
        ;;
        outdated)
            completions="$COMMON_OPTIONS $OUTDATED_OPTIONS"
        ;;
        pristine)
            completions="$COMMON_OPTIONS $PRISTINE_OPTIONS"
        ;;
        query)
            completions="$COMMON_OPTIONS $QUERY_OPTIONS"
        ;;
        rdoc)
            completions="$COMMON_OPTIONS $RDOC_OPTIONS"
        ;;
        search)
            completions="$COMMON_OPTIONS $SEARCH_OPTIONS"
        ;;
        server)
            completions="$COMMON_OPTIONS $SERVER_OPTIONS"
        ;;
        sources)
            completions="$COMMON_OPTIONS $SOURCES_OPTIONS"
        ;;
        specification)
            completions="$COMMON_OPTIONS $SPECIFICATION_OPTIONS"
        ;;
        uninstall)
            completions="$COMMON_OPTIONS $UNINSTALL_OPTIONS"
        ;;
        unpack)
            completions="$COMMON_OPTIONS $UNPACK_OPTIONS"
        ;;
        update)
            completions="$COMMON_OPTIONS $UPDATE_OPTIONS"
        ;;
        which)
            completions="$COMMON_OPTIONS $WHICH_OPTIONS"
        ;;
        *)
            completions="$COMMANDS $GEM_OPTIONS"
        ;;
    esac;
    COMPREPLY=($( compgen -W "$completions" -- $cur ));
    return 0
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if [[ $COMP_CWORD -ge 1 ]]; then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_grub_editenv () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        create | list | set | unset)
            COMPREPLY=("");
            return
        ;;
    esac;
    __grubcomp "$(__grub_get_options_from_help)
                create list set unset"
}
_grub_install () 
{ 
    local cur prev last split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
        --disk-module)
            __grubcomp "biosdisk ata";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_mkconfig () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkfont () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkimage () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory | -p | --prefix)
            _filedir -d;
            return
        ;;
        -O | --format)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F ":" '/available formats/ { print $2 }' |                         sed 's/, / /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkpasswd_pbkdf2 () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_mkrescue () 
{ 
    local cur prev last;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    last=$(__grub_get_last_option);
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        case "$last" in 
            --modules)
                __grub_list_modules;
                return
            ;;
        esac;
        _filedir;
    fi
}
_grub_probe () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -t | --target)
            local prog=${COMP_WORDS[0]};
            __grubcomp "$(LC_ALL=C $prog --help |                         awk -F "[()]" '/--target=/ { print $2 }' |                         sed 's/|/ /g')";
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_script_check () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_grub_set_entry () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        --boot-directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        __grub_list_menuentries;
    fi
}
_grub_setup () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --directory)
            _filedir -d;
            return
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        __grubcomp "$(__grub_get_options_from_help)";
    else
        _filedir;
    fi
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_hg () 
{ 
    local cur prev cmd cmd_index opts i;
    local global_args='--cwd|-R|--repository';
    local hg="$1";
    local canonical=0;
    COMPREPLY=();
    cur="$2";
    prev="$3";
    for ((i=1; $i<=$COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                cmd="${COMP_WORDS[i]}";
                cmd_index=$i;
                break;
            fi;
        fi;
    done;
    if [[ "$cur" == -* ]]; then
        if [ "$(type -t "_hg_opt_$cmd")" = function ] && "_hg_opt_$cmd"; then
            return;
        fi;
        opts=$(_hg_cmd debugcomplete --options "$cmd");
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$opts' -- "$cur"));
        return;
    fi;
    case "$prev" in 
        -R | --repository)
            _hg_paths;
            _hg_repos;
            return
        ;;
        --cwd)
            return
        ;;
    esac;
    if [ -z "$cmd" ] || [ $COMP_CWORD -eq $i ]; then
        _hg_commands;
        return;
    fi;
    local help;
    if _hg_command_specific; then
        return;
    fi;
    help=$(_hg_cmd help "$cmd");
    if [ $? -ne 0 ]; then
        return;
    fi;
    cmd=${help#hg };
    cmd=${cmd%%[' 
']*};
    canonical=1;
    _hg_command_specific
}
_hg_bookmarks () 
{ 
    local bookmarks="$(_hg_cmd bookmarks -q)";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$bookmarks' -- "$cur"))
}
_hg_cmd () 
{ 
    HGPLAIN=1 "$hg" "$@" 2> /dev/null
}
_hg_cmd_bisect () 
{ 
    local i subcmd;
    for ((i=cmd_index+1; i<=COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                subcmd="${COMP_WORDS[i]}";
                break;
            fi;
        fi;
    done;
    if [ -z "$subcmd" ] || [ $COMP_CWORD -eq $i ] || [ "$subcmd" = help ]; then
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W 'bad good help init next reset' -- "$cur"));
        return;
    fi;
    case "$subcmd" in 
        good | bad)
            _hg_labels
        ;;
    esac;
    return
}
_hg_cmd_bookmarks () 
{ 
    if [[ "$prev" = @(-d|--delete|-m|--rename) ]]; then
        _hg_bookmarks;
        return;
    fi
}
_hg_cmd_email () 
{ 
    case "$prev" in 
        -c | --cc | -t | --to | -f | --from | --bcc)
            if [ "$(type -t _hg_emails)" = function ]; then
                local arg=to;
                if [[ "$prev" == @(-f|--from) ]]; then
                    arg=from;
                fi;
                local addresses=$(_hg_emails $arg);
                COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$addresses' -- "$cur"));
            fi;
            return
        ;;
        -m | --mbox)
            return
        ;;
        -s | --subject)
            return
        ;;
    esac;
    _hg_labels;
    return
}
_hg_cmd_qclone () 
{ 
    local count=$(_hg_count_non_option);
    if [ $count = 1 ]; then
        _hg_paths;
    fi;
    _hg_repos
}
_hg_cmd_qcommit () 
{ 
    local root=$(_hg_cmd root);
    local files=$(cd "$root/.hg/patches" && _hg_cmd status -nmar);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_hg_cmd_qdelete () 
{ 
    local qcmd=qunapplied;
    if [[ "$prev" = @(-r|--rev) ]]; then
        qcmd=qapplied;
    fi;
    _hg_ext_mq_patchlist $qcmd
}
_hg_cmd_qfinish () 
{ 
    if [[ "$prev" = @(-a|--applied) ]]; then
        return;
    fi;
    _hg_ext_mq_patchlist qapplied
}
_hg_cmd_qfold () 
{ 
    _hg_ext_mq_patchlist qunapplied
}
_hg_cmd_qgoto () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qguard () 
{ 
    local prefix='';
    if [[ "$cur" == +* ]]; then
        prefix=+;
    else
        if [[ "$cur" == -* ]]; then
            prefix=-;
        fi;
    fi;
    local ncur=${cur#[-+]};
    if ! [ "$prefix" ]; then
        _hg_ext_mq_patchlist qseries;
        return;
    fi;
    local guards=$(_hg_ext_mq_guards);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -P $prefix -W '$guards' -- "$ncur"))
}
_hg_cmd_qheader () 
{ 
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qpop () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qapplied
}
_hg_cmd_qpush () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qunapplied
}
_hg_cmd_qqueue () 
{ 
    local q;
    local queues;
    local opts="--list --create --rename --delete --purge";
    queues=$( _hg_cmd qqueue --quiet );
    COMPREPLY=($( compgen -W "${opts} ${queues}" "${cur}" ))
}
_hg_cmd_qrename () 
{ 
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qsave () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi
}
_hg_cmd_qselect () 
{ 
    local guards=$(_hg_ext_mq_guards);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$guards' -- "$cur"))
}
_hg_cmd_rebase () 
{ 
    if [[ "$prev" = @(-s|--source|-d|--dest|-b|--base|-r|--rev) ]]; then
        _hg_labels;
        return;
    fi
}
_hg_cmd_shelve () 
{ 
    _hg_status "mard"
}
_hg_cmd_sign () 
{ 
    _hg_labels
}
_hg_cmd_strip () 
{ 
    _hg_labels
}
_hg_cmd_transplant () 
{ 
    case "$prev" in 
        -s | --source)
            _hg_paths;
            _hg_repos;
            return
        ;;
        --filter)
            return
        ;;
    esac;
    _hg_labels;
    return
}
_hg_cmd_unshelve () 
{ 
    _hg_shelves
}
_hg_command_specific () 
{ 
    if [ "$(type -t "_hg_cmd_$cmd")" = function ]; then
        "_hg_cmd_$cmd";
        return 0;
    fi;
    if [ "$cmd" != status ] && [ "$prev" = -r ] || [ "$prev" == --rev ]; then
        if [ $canonical = 1 ]; then
            _hg_labels;
            return 0;
        else
            if [[ status != "$cmd"* ]]; then
                _hg_labels;
                return 0;
            else
                return 1;
            fi;
        fi;
    fi;
    case "$cmd" in 
        help)
            _hg_commands
        ;;
        export)
            if _hg_ext_mq_patchlist qapplied && [ "${COMPREPLY[*]}" ]; then
                return 0;
            fi;
            _hg_labels
        ;;
        manifest | update | up | checkout | co)
            _hg_labels
        ;;
        pull | push | outgoing | incoming)
            _hg_paths;
            _hg_repos
        ;;
        paths)
            _hg_paths
        ;;
        add)
            _hg_status "u"
        ;;
        merge)
            _hg_labels
        ;;
        commit | ci | record)
            _hg_status "mar"
        ;;
        remove | rm)
            _hg_debugpathcomplete -n
        ;;
        forget)
            _hg_debugpathcomplete -fa
        ;;
        diff)
            _hg_status "mar"
        ;;
        revert)
            _hg_debugpathcomplete
        ;;
        clone)
            local count=$(_hg_count_non_option);
            if [ $count = 1 ]; then
                _hg_paths;
            fi;
            _hg_repos
        ;;
        debugindex | debugindexdot)
            COMPREPLY=(${COMPREPLY[@]:-} $(compgen -f -X "!*.i" -- "$cur"))
        ;;
        debugdata)
            COMPREPLY=(${COMPREPLY[@]:-} $(compgen -f -X "!*.d" -- "$cur"))
        ;;
        *)
            return 1
        ;;
    esac;
    return 0
}
_hg_commands () 
{ 
    local commands;
    commands="$(HGPLAINEXCEPT=alias _hg_cmd debugcomplete "$cur")" || commands="";
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$commands' -- "$cur"))
}
_hg_count_non_option () 
{ 
    local i count=0;
    local filters="$1";
    for ((i=1; $i<=$COMP_CWORD; i++))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} == @($filters|$global_args) ]]; then
                continue;
            fi;
            count=$(($count + 1));
        fi;
    done;
    echo $(($count - 1))
}
_hg_debugpathcomplete () 
{ 
    local files="$(_hg_cmd debugpathcomplete $1 "$cur")";
    local IFS='
';
    compopt -o filenames 2> /dev/null;
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_hg_ext_mq_guards () 
{ 
    _hg_cmd qselect --series | sed -e 's/^.//'
}
_hg_ext_mq_patchlist () 
{ 
    local patches;
    patches=$(_hg_cmd $1);
    if [ $? -eq 0 ] && [ "$patches" ]; then
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$patches' -- "$cur"));
        return 0;
    fi;
    return 1
}
_hg_ext_mq_queues () 
{ 
    local root=$(_hg_cmd root);
    local n;
    for n in $(cd "$root"/.hg && compgen -d -- "$cur");
    do
        if [ "$n" != patches ] && [ -e "$root/.hg/$n/series" ]; then
            COMPREPLY=(${COMPREPLY[@]:-} "$n");
        fi;
    done
}
_hg_labels () 
{ 
    local labels="$(_hg_cmd debuglabelcomplete "$cur")";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$labels' -- "$cur"))
}
_hg_opt_qguard () 
{ 
    local i;
    for ((i=cmd_index+1; i<=COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                _hg_cmd_qguard;
                return 0;
            fi;
        else
            if [ "${COMP_WORDS[i]}" = -- ]; then
                _hg_cmd_qguard;
                return 0;
            fi;
        fi;
    done;
    return 1
}
_hg_paths () 
{ 
    local paths="$(_hg_cmd paths -q)";
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$paths' -- "$cur"))
}
_hg_repos () 
{ 
    local i;
    for i in $(compgen -d -- "$cur");
    do
        test ! -d "$i"/.hg || COMPREPLY=(${COMPREPLY[@]:-} "$i");
    done
}
_hg_shelves () 
{ 
    local shelves="$(_hg_cmd unshelve -l .)";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$shelves' -- "$cur"))
}
_hg_status () 
{ 
    local files="$(_hg_cmd status -n$1 "glob:$cur**")";
    local IFS='
';
    compopt -o filenames 2> /dev/null;
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_init_completion () 
{ 
    local exclude= flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || $prev == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=$errx
            ;;
            *'>'*)
                xspec=$outx
            ;;
            *'<'*)
                xspec=$inx
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=$errx
                    ;;
                    *'>'*)
                        xspec=$outx
                    ;;
                    *'<'*)
                        xspec=$inx
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            [[ $i -le $cword ]] && cword=$(( cword - skip ));
        else
            i=$(( ++i ));
        fi;
    done;
    [[ $cword -le 0 ]] && return 1;
    prev=${words[cword-1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_ip_addresses () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY+=($( compgen -W         "$( { LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null |
            sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'                 -ne 's|.*inet[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p' )"         -- "$cur" ))
}
_kernel_versions () 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_kernels () 
{ 
    COMPREPLY=($( cd /lib/modules && compgen -d -- "$cur" ))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    _known_hosts_real $options -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [[ $# -lt $OPTIND ]] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [[ $# -ge $OPTIND ]] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    if [[ ${#config[@]} -gt 0 ]]; then
        local OIFS=$IFS IFS='
' j;
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        IFS=$OIFS;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ -z $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [[ -z $awkcur ]]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [[ ${#kh[@]} -gt 0 ]]; then
            COMPREPLY+=($( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {
            sub("^@[^ ]+ +", ""); \
            sub(" .*$", ""); \
            for (i=1; i<=NF; ++i) { \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i !~ /[*?]/ && $i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [[ ${#khd[@]} -gt 0 ]]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}['"$'\t '"']\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY+=($( compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    COMPREPLY+=($( compgen -W         "$( ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }' )"         -- "$cur" ));
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return 0
        ;;
        --*dir*)
            _filedir -d;
            return 0
        ;;
        --*file* | --*path*)
            _filedir;
            return 0
        ;;
        --+([-a-z0-9_]))
            local argtype=$( $1 --help 2>&1 | sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p" );
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return 0
                ;;
                *file* | *path*)
                    _filedir;
                    return 0
                ;;
            esac
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}=\{0,1\}\).*/\1/p' | sort -u )"             -- "$cur" ));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(         { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
        ));
    COMPREPLY+=($( { arp -an || ip neigh show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY+=($( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -RL $modpath 2>/dev/null |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
_mvn () 
{ 
    local i prev c=1 cmd option optionArg=0 cmdcomplete=0;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=();
    while [ $c -le $COMP_CWORD ]; do
        prev=$i;
        i="${COMP_WORDS[c]}";
        c=$((++c));
        optionArg=0;
        if [[ $prev == @(${__mvnoptsWithArg}) ]]; then
            optionArg=1;
            continue;
        fi;
        if [[ $cmdcomplete == -3 ]]; then
            cmdcomplete=1;
            break;
        fi;
        if [[ "$i" == "" ]]; then
            if [[ -n $cmd ]]; then
                cmdcomplete=1;
                break;
            fi;
            continue;
        fi;
        if [[ "$i" == ":" ]]; then
            if [[ -n $cmd ]]; then
                cmdcomplete=$((cmdcomplete-1));
                cmd="${cmd}:";
            fi;
            continue;
        fi;
        case "$i" in 
            --version | --help)
                return
            ;;
            -*)
                option="$i"
            ;;
            *)
                if [[ ! -n $cmd ]]; then
                    cmdcomplete=$((cmdcomplete-1));
                    cmd="$i";
                    local next=$c;
                    if [[ $next -lt $COMP_CWORD ]]; then
                        if [[ "${COMP_WORDS[next]}" != ":" ]]; then
                            break;
                        fi;
                    fi;
                else
                    cmdcomplete=$((cmdcomplete-1));
                    cmd="$cmd$i";
                fi
            ;;
        esac;
    done;
    if [[ ! -n $cmd && -n $option && ( $optionArg == 0 ) ]]; then
        case "$option" in 
            --file)
                __mvncomp "$(__mvnlist_poms)";
                return
            ;;
            --define)
                __mvncomp "maven.test.skip=true";
                return
            ;;
            --resume-from)
                __mvncomp "$(__mvnlist_projects)";
                return
            ;;
            --projects)
                case "${cur}" in 
                    *,*)
                        __mvncomp "$(__mvnlist_projects)" "$(__mvnprefix_comma $cur)" "${cur#*,}"
                    ;;
                    *)
                        __mvncomp "$(__mvnlist_projects)"
                    ;;
                esac;
                return
            ;;
            --settings | --global-settings)
                COMPREPLY=($( compgen -f -- $cur ));
                return
            ;;
            --*)
                COMPREPLY=()
            ;;
        esac;
    fi;
    if [ $cmdcomplete -lt 0 ]; then
        case "${cmd}" in 
            *:)
                local plugin="${cmd%%:}:";
                __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_colon $cmd)" ""
            ;;
            *:*)
                local plugin="${cmd%%:*}:";
                __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_colon $cmd)" "${cmd#*:}"
            ;;
            *)
                __mvncomp "${__mvnphases} ${__mvnall_plugin_and_goals}"
            ;;
        esac;
        return;
    fi;
    if [ -z "$cmd" ]; then
        case "${cur}" in 
            -D*=*)
                COMPREPLY=()
            ;;
            -*)
                __mvncomp "${__mvnopts} ${__mvnparams}"
            ;;
            --*)
                __mvncomp "${__mvnopts}"
            ;;
            *)
                __mvncomp "${__mvnphases} ${__mvnall_plugin_and_goals}"
            ;;
        esac;
        return;
    fi;
    case "$cmd" in 
        *:help)
            local plugin="${cmd%%:*}:";
            __mvnplugin_help $plugin
        ;;
        help:describe)
            __mvnhelp_describe
        ;;
        deploy:deploy)
            __mvndeploy_deploy
        ;;
        deploy:deploy-file)
            __mvndeploy_deploy_file
        ;;
        archetype:generate)
            __mvnarchetype_generate
        ;;
        dependency:copy-dependencies)
            __mvndependency_x_dependencies
        ;;
        dependency:unpack-dependencies)
            __mvndependency_x_dependencies
        ;;
        dependency:resolve)
            __mvndependency_resolve
        ;;
        dependency:resolve-plugins)
            __mvndependency_resolve
        ;;
        dependency:source)
            __mvndependency_resolve
        ;;
        dependency:go-offline)
            __mvndependency_resolve
        ;;
        dependency:purge-local-repository)
            __mvndependency_purge_local_repository
        ;;
        dependency:analyze)
            __mvndependency_analyze
        ;;
        dependency:analyze-dep-mgt)
            __mvndependency_analyze_dep_mgt
        ;;
        install:install-file)
            __mvninstall_install_file
        ;;
        release:prepare)
            __mvnrelease_prepare
        ;;
        scm:checkin)
            __mvnscm_checkin
        ;;
        *)

        ;;
    esac
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$( getconf $var 2>/dev/null );
    printf %s ${n:-1}
}
_pacat () 
{ 
    local cur prev comps;
    local flags='-h --help --version -r --record -p --playback -v --verbose -s
                --server= -d --device= -n --client-name= --stream-name= --volume=
                --rate= --format= --channels= --channel-map= --fix-format --fix-rate
                --fix-channels --no-remix --no-remap --latency= --process-time=
                --latency-msec= --process-time-msec= --property= --raw --passthrough
                --file-format= --list-file-formats';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        --device=*)
            cur=${cur#*=};
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --rate=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '32000 44100 48000 9600 192000' -- "$cur"))
        ;;
        --file-format=*)
            cur=${cur#*=};
            comps=$(_pacat_file_formats);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            _filedir
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
        -d)
            comps=$(__sinks);
            comps+=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_pacat_file_formats () 
{ 
    while IFS='	' read name _; do
        printf "%s\n" "$name";
    done < <(pacat --list-file-formats 2> /dev/null)
}
_pacmd () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version';
    local commands=(exit help list-modules list-sinks list-sources list-clients list-samples list-sink-inputs list-source-outputs stat info load-module unload-module describe-module set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mut set-sink-input-mute set-source-output-mute update-sink-proplist update-source-proplist update-sink-input-proplist update-source-output-proplist set-default-sink set-default-source kill-client kill-sink-input kill-source-output play-sample remove-sample load-sample load-sample-lazy load-sample-dir-lazy play-file dump move-sink-input move-source-output suspend-sink suspend-source suspend set-card-profile set-sink-port set-source-port set-port-latency-offset set-log-target set-log-level set-log-meta set-log-time set-log-backtrace);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        play-sample | play-file)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample*)
            _filedir
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*port*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
    esac;
    case $prev in 
        list-*)

        ;;
        describe-module | load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        load-sample-dir-lazy)
            _filedir -d
        ;;
        play-file)
            _filedir
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port-*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-log-target)
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        set-log-level)
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        set-log-meta | set-log-time | suspend)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
    esac;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
        suspend)
            COMPREPLY=($(compgen -W 'suspend suspend-sink suspend-source' -- "$cur"))
        ;;
        load-sample)
            COMPREPLY=($(compgen -W 'load-sample load-sample-lazy load-sample-dir-lazy' -- "$cur"))
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_pactl () 
{ 
    local cur prev words cword preprev command;
    local comps;
    local flags='-h --help --version -s --server= --client-name=';
    local list_types='short sinks sources sink-inputs source outputs cards
                    modules samples clients';
    local commands=(stat info list exit upload-sample play-sample remove-sample load-module unload-module move-sink-input move-source-output suspend-sink suspend-source set-card-profile set-sink-port set-source-port set-sink-volume set-source-volume set-sink-input-volume set-source-output-volume set-sink-mute set-source-mute set-sink-input-mute set-source-output-mute set-sink-formats set-port-latency-offset subscribe help);
    _init_completion -n = || return;
    preprev=${words[$cword-2]};
    for word in "${COMP_WORDS[@]}";
    do
        if in_array "$word" "${commands[@]}"; then
            command=$word;
            break;
        fi;
    done;
    case $preprev in 
        list)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        play-sample)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-sink-input)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        move-source-output)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card-profile)
            comps=$(__profiles);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-port)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-*-mute)
            COMPREPLY=($(compgen -W 'true false toggle' -- "$cur"))
        ;;
        set-sink-formats)

        ;;
        set-port-*)
            comps=$(__ports);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --server)
            compopt +o nospace;
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $prev in 
        list)
            COMPREPLY=($(compgen -W '${list_types[*]}' -- "$cur"))
        ;;
        stat)
            COMPREPLY=($(compgen -W 'short' -- "$cur"))
        ;;
        upload-sample)
            _filedir
        ;;
        play-sample)

        ;;
        remove-sample)

        ;;
        load-module)
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        unload-module)
            comps=$(__loaded_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-card*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink-input*)
            comps=$(__sink_inputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source-output*)
            comps=$(__source_outputs);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-sink-formats)
            comps=$(__sinks_idx);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *sink*)
            comps=$(__sinks);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        *source*)
            comps=$(__sources);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        set-port*)
            comps=$(__cards);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        -s)
            _known_hosts_real "$cur"
        ;;
    esac;
    [[ -n $COMPREPLY ]] && return 0;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
        *)
            [[ -z $command ]] && COMPREPLY=($(compgen -W '${commands[*]}' -- "$cur"))
        ;;
    esac
}
_padsp () 
{ 
    local cur prev;
    local flags='-h -s -n -m -M -S -D -d';
    _get_comp_words_by_ref cur prev;
    case $cur in 
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"))
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_parse_help () 
{ 
    eval local cmd=$( quote "$1" );
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([ '	'])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd=$( quote "$1" );
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i=1; i < ${#option}; i++ ))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pasuspender () 
{ 
    local cur prev;
    local flags='-h --help --version -s --server=';
    _init_completion -n = || return;
    case $cur in 
        --server=*)
            cur=${cur#*=};
            _known_hosts_real "$cur"
        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -s)
            _known_hosts_real "$cur"
        ;;
    esac
}
_pci_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_pgids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pnames () 
{ 
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
_poff () 
{ 
    local prev cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    prev=${COMP_WORDS[COMP_CWORD-1]};
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '-r -d -c -a -h -v' -- $cur));
        return 0;
    fi;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" != -* ]] || [[ "$prev" == -* ]]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pon () 
{ 
    local cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pulseaudio () 
{ 
    local cur prev words cword;
    local flags='-h --help --version --dump-conf --dump-resample-methods --cleanup-shm
                --start -k --kill --check --system= -D --daemonize= --fail= --high-priority=
                --realtime= --disallow-module-loading= --disallow-exit= --exit-idle-time=
                --scache-idle-time= --log-level= -v --log-target= --log-meta= --log-time=
                --log-backtrace= -p --dl-search-path= --resample-method= --use-pit-file=
                --no-cpu-limit= --disable-shm= -L --load= -F --file= -C -n';
    _init_completion -n = || return;
    case $cur in 
        --system=* | --daemonize=* | --fail=* | --high-priority=* | --realtime=* | --disallow-*=* | --log-meta=* | --log-time=* | --use-pid-file=* | --no-cpu-limit=* | --disable-shm=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        --log-target=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W 'auto syslog stderr file: newfile:' -- "$cur"))
        ;;
        --log-level=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W '{0..4}' -- "$cur"))
        ;;
        --dl-search-path=*)
            cur=${cur#*=};
            _filedir -d
        ;;
        --file=*)
            cur=${cur#*=};
            _filedir
        ;;
        --resample-method=*)
            cur=${cur#*=};
            comps=$(__resample_methods);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --load=*)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
        --*=*)

        ;;
        -*)
            COMPREPLY=($(compgen -W '${flags[*]}' -- "$cur"));
            [[ $COMPREPLY == *= ]] && compopt -o nospace
        ;;
    esac;
    case $prev in 
        -D)
            COMPREPLY=($(compgen -W 'true false' -- "$cur"))
        ;;
        -p)
            _filedir -d
        ;;
        -F)
            _filedir
        ;;
        -L)
            cur=${cur#*=};
            comps=$(__all_modules);
            COMPREPLY=($(compgen -W '${comps[*]}' -- "$cur"))
        ;;
    esac
}
_quote_readline_by_ref () 
{ 
    if [ -z "$1" ]; then
        printf -v $2 %s "$1";
    else
        if [[ $1 == \'* ]]; then
            printf -v $2 %s "${1:1}";
        else
            if [[ $1 == \~* ]]; then
                printf -v $2 \~%q "${1:1}";
            else
                printf -v $2 %q "$1";
            fi;
        fi;
    fi;
    [[ ${!2} == *\\* ]] && printf -v $2 %s "${1//\\\\/\\}";
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_rl_enabled () 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    [[ $cword -gt 2 ]] && return 0;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($( compgen -W '`sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur" ));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local restore_nullglob=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($( printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions) ));
    $restore_nullglob;
    COMPREPLY+=($( systemctl list-units --full --all 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur" ))
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($( compgen -P "$1" -A signal "SIG${cur#$1}" ));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_subdirectories () 
{ 
    COMPREPLY=($( cd $1 && compgen -d -- "$cur" ))
}
_svn () 
{ 
    local cur cmds cmdOpts pOpts mOpts rOpts qOpts nOpts optsParam opt;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='add blame annotate praise cat changelist cl checkout co cleanup';
    cmds="$cmds commit ci copy cp delete remove rm diff export help import";
    cmds="$cmds info list ls lock log merge mergeinfo mkdir move mv rename";
    cmds="$cmds patch propdel pdel propedit pedit propget pget proplist";
    cmds="$cmds plist propset pset relocate resolve resolved revert status";
    cmds="$cmds  switch unlock update upgrade";
    local helpOpts='--help -h';
    local specOpts="--version $helpOpts";
    optsParam="-r|--revision|--username|--password|--targets";
    optsParam="$optsParam|-x|--extensions|-m|--message|-F|--file";
    optsParam="$optsParam|--encoding|--diff-cmd|--diff3-cmd|--editor-cmd";
    optsParam="$optsParam|--old|--new|--config-dir|--config-option";
    optsParam="$optsParam|--native-eol|-l|--limit|-c|--change";
    optsParam="$optsParam|--depth|--set-depth|--with-revprop";
    optsParam="$optsParam|--cl|--changelist|--accept|--show-revs";
    local svnProps revProps allProps psCmds propCmds;
    svnProps="svn:keywords svn:executable svn:needs-lock svn:externals
	          svn:ignore svn:eol-style svn:mime-type $SVN_BASH_FILE_PROPS";
    revProps="svn:author svn:log svn:date $SVN_BASH_REV_PROPS";
    allProps=($svnProps $revProps);
    psCmds='propset|pset|ps';
    propCmds="$psCmds|propget|pget|pg|propedit|pedit|pe|propdel|pdel|pd";
    local urlSchemas='file:/// http:// https:// svn:// svn+ssh://';
    local cmd= isPropCmd= isPsCmd= isHelpCmd= nExpectArgs= isCur= i=0;
    local prev= help= prop= val= isRevProp= last='none' nargs=0 stat=;
    local options= hasRevPropOpt= hasRevisionOpt= hasRelocateOpt=;
    local acceptOpt= URL= hasReintegrateOpt=;
    for opt in "${COMP_WORDS[@]}";
    do
        [[ -n $isCur ]] && stat=$last;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        let i++;
        [ $last = 'none' ] && { 
            last='first';
            continue
        };
        if [[ $prev == @($optsParam) ]]; then
            [[ $prev = '--accept' ]] && acceptOpt=$opt;
            prev='';
            last='skip';
            continue;
        fi;
        if [[ $prev == @(<|>|>>|[12]>|[12]>>) ]]; then
            prev='';
            last='skip';
            continue;
        fi;
        prev=$opt;
        if [[ ! -n $cmd && -n $opt && ( $opt != -* || $opt == @(${specOpts// /|}) ) ]]; then
            cmd=$opt;
            [[ $cmd == @($propCmds) ]] && isPropCmd=1;
            [[ $cmd == @($psCmds) ]] && isPsCmd=1;
            [[ $cmd == @(${helpOpts// /|}) ]] && cmd='help';
            [[ $cmd = 'help' ]] && isHelpCmd=1;
            if [[ -n $isHelpCmd && -n $cmd && $cmd != 'help' && ! -n $help ]]; then
                help=$cmd;
                cmd='help';
            fi;
            last='cmd';
            continue;
        fi;
        if [[ -n $isHelpCmd && ! -n $help && -n $opt && $opt != -* ]]; then
            help=$opt;
            last='help';
            continue;
        fi;
        if [[ -n $isPropCmd && ! -n $prop && -n $opt && $opt != -* ]]; then
            prop=$opt;
            [[ $prop == @(${revProps// /|}) ]] && isRevProp=1;
            last='prop';
            continue;
        fi;
        if [[ -n $isPsCmd && -n $prop && ! -n $val && $opt != -* ]]; then
            val=$opt;
            last='val';
            continue;
        fi;
        if [[ $last != 'onlyarg' ]]; then
            case $opt in 
                -r | --revision | --revision=*)
                    hasRevisionOpt=1
                ;;
                --revprop)
                    hasRevPropOpt=1;
                    allProps=($revProps);
                    nExpectArgs=1
                ;;
                -h | --help)
                    isHelpCmd=1
                ;;
                -F | --file)
                    val='-F'
                ;;
                --relocate)
                    hasRelocateOpt=1
                ;;
                --reintegrate)
                    hasReintegrateOpt=1
                ;;
            esac;
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='onlyarg';
                continue;
            fi;
            if [[ $opt == -* ]]; then
                [[ ! -n $isCur ]] && options="$options $opt ";
                last='opt';
                continue;
            fi;
        else
            let nargs++;
            continue;
        fi;
        if [[ $cmd = 'merge' && ! -n $URL ]]; then
            URL=$opt;
        fi;
        last='arg';
        let nargs++;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ ! -n $cmd || $stat = 'cmd' ]]; then
        COMPREPLY=($( compgen -W "$cmds $specOpts" -- $cur ));
        return 0;
    fi;
    if [[ $stat = 'help' || ( -n $isHelpCmd && ! -n $help ) ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    if [[ $cmd == @(co|checkout|ls|list) && $stat = 'arg' && $SVN_BASH_COMPL_EXT == *urls* ]]; then
        if [[ $cur == file:* ]]; then
            local where=${cur/file:/};
            COMPREPLY=($(compgen -d -S '/' -X '*/.*' -- $where ));
            return;
        else
            if [[ $cur == *:* ]]; then
                local urls= file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        local url=$(_svn_read_hashfile svn:realmstring < $file);
                        url=${url/*</};
                        url=${url/>*/};
                        urls="$urls $url";
                    fi;
                done;
                local prefix=${cur%:*} suffix=${cur#*:} c= choices=;
                for c in $urls;
                do
                    [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
                done;
                COMPREPLY=($(compgen -W "$choices" -- $suffix ));
                return;
            else
                COMPREPLY=($(compgen -W "$urlSchemas" -- $cur));
                return;
            fi;
        fi;
    fi;
    if [[ $cmd = 'merge' || $cmd = 'mergeinfo' ]]; then
        local here=$(_svn_info URL);
        if [[ ! -n $URL && $stat = 'arg' ]]; then
            if [[ "$here" == */branches/* ]]; then
                COMPREPLY=($(compgen -W ${here/\/branches\/*/\/trunk} -- $cur ));
                return 0;
            else
                if [[ "$here" == */trunk* ]]; then
                    COMPREPLY=($(compgen -W ${here/\/trunk*/\/branches\/} -- $cur ));
                    return 0;
                else
                    COMPREPLY=($(compgen -W $(_svn_info Root) -- $cur ));
                    return 0;
                fi;
            fi;
        else
            if [[ $URL == */branches/* && $here == */trunk* && ! -n $hasReintegrateOpt && $cur = '' && $stat = 'arg' ]]; then
                COMPREPLY=($(compgen -W '--reintegrate' -- $cur ));
                return 0;
            fi;
        fi;
    fi;
    if [[ $stat = 'skip' ]]; then
        local previous=${COMP_WORDS[COMP_CWORD-1]};
        local values= dirs= beep= exes=;
        [[ $previous = '--config-dir' ]] && dirs=1;
        [[ $previous = --*-cmd ]] && exes=1;
        [[ $previous = '--native-eol' ]] && values='LF CR CRLF';
        [[ $previous = '--limit' ]] && values='0 1 2 3 4 5 6 7 8 9';
        [[ $previous = '--revision' || $previous = '-r' ]] && values='HEAD BASE PREV COMMITTED 0 {';
        [[ $previous = '--encoding' ]] && values="latin1 utf8 $SVN_BASH_ENCODINGS";
        [[ $previous = '--extensions' || $previous = '-x' ]] && values="--unified --ignore-space-change 		   --ignore-all-space --ignore-eol-style --show-c-functions";
        [[ $previous = '--depth' ]] && values='empty files immediates infinity';
        [[ $previous = '--set-depth' ]] && values='empty exclude files immediates infinity';
        [[ $previous = '--accept' ]] && { 
            if [[ $cmd = 'resolve' ]]; then
                values='base working mine-full theirs-full';
            else
                values="postpone base mine-full theirs-full edit launch 			mine-conflict theirs-conflict";
            fi
        };
        [[ $previous = '--show-revs' ]] && values='merged eligible';
        if [[ $previous = '--username' ]]; then
            values="$SVN_BASH_USERNAME";
            if [[ $SVN_BASH_COMPL_EXT == *username* ]]; then
                local file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        values="$values $(_svn_read_hashfile username < $file)";
                    fi;
                done;
            fi;
            [[ ! -n "$values" ]] && beep=1;
        fi;
        [[ $previous = '--password' ]] && beep=1;
        [[ -n $values ]] && COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n $dirs ]] && COMPREPLY=($( compgen -o dirnames -- $cur ));
        [[ -n $exes ]] && COMPREPLY=($( compgen -c -- $cur ));
        [[ -n $beep ]] && { 
            echo -en "\a";
            COMPREPLY=('')
        };
        return 0;
    fi;
    if [[ -n $isPropCmd && ( ! -n $prop || $stat = 'prop' ) && $cur != -* ]]; then
        local choices=;
        if [[ $cur == *:* ]]; then
            local prefix=${cur%:*} suffix=${cur#*:} c=;
            for c in ${allProps[@]};
            do
                [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
            done;
            cur=$suffix;
        else
            COMPREPLY=($( compgen -W "${allProps[*]}" -- $cur ));
            [ ${#COMPREPLY[@]} -eq 1 ] && return 0;
            local seen= n=0 last= c=;
            for c in ${allProps[@]%:*};
            do
                if [[ $c == $cur* && ( ! -n $seen || $c != @($seen) ) ]]; then
                    let n++;
                    last=$c;
                    choices="$choices $c:";
                    if [[ -n $seen ]]; then
                        seen="$seen|$c*";
                    else
                        seen="$c*";
                    fi;
                fi;
            done;
            [[ $n -eq 1 ]] && choices="$last:1 $last:2";
        fi;
        COMPREPLY=($( compgen -W "$choices" -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && ! -n $hasRevPropOpt ]]; then
        COMPREPLY=($( compgen -W '--revprop' -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && -n $hasRevPropOpt && ! -n $hasRevisionOpt ]]; then
        COMPREPLY=($( compgen -W '--revision' -- $cur ));
        return 0;
    fi;
    if [[ -n $isPsCmd && -n $prop && ( ! -n $val || $stat = 'val' ) ]]; then
        local values="\' --file";
        case $prop in 
            svn:keywords)
                values="Id Rev URL Date Author Header \' $SVN_BASH_KEYWORDS"
            ;;
            svn:executable | svn:needs-lock)
                values='\\*'
            ;;
            svn:eol-style)
                values='native LF CR CRLF'
            ;;
            svn:mime-type)
                values="text/ text/plain text/html text/xml text/rtf
                       image/ image/png image/gif image/jpeg image/tiff
                       audio/ audio/midi audio/mpeg
                       video/ video/mpeg video/mp4
                       application/ application/octet-stream
                       $SVN_BASH_MIME_TYPE"
            ;;
        esac;
        COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n ${COMPREPLY} ]] && return 0;
    fi;
    case $cmd in 
        merge)
            nExpectArgs=3
        ;;
        mergeinfo)
            nExpectArgs=1
        ;;
        copy | cp | move | mv | rename | ren | export | import)
            nExpectArgs=2
        ;;
        switch | sw)
            [[ ! -n $hasRelocateOpt ]] && nExpectArgs=2
        ;;
        help | h)
            nExpectArgs=0
        ;;
        --version)
            nExpectArgs=0
        ;;
    esac;
    if [[ -n $nExpectArgs && $nargs -gt $nExpectArgs ]]; then
        echo -en "\a";
        COMPREPLY=('');
        return 0;
    fi;
    if [[ $cur != -* || $stat = 'onlyarg' ]]; then
        if [[ $SVN_BASH_COMPL_EXT == *svnstatus* ]]; then
            local status='svn status --non-interactive';
            [[ $SVN_BASH_COMPL_EXT == *recurse* ]] || status="$status --non-recursive";
            [[ $SVN_BASH_COMPL_EXT == *externals* ]] || status="$status --ignore-externals";
            local cs= files=;
            [[ -n $cur ]] && cs=$cur*;
            case $cmd in 
                st*)
                    files=$cur*
                ;;
                ci | commit | revert | di*)
                    files=$($status $cs| _svn_grcut '@([MADR!]*| M*|_M*)')
                ;;
                add)
                    files=$($status $cs| _svn_grcut '\?*')
                ;;
                unlock)
                    files=$($status $cs| _svn_grcut '@(??L*|?????[KOTB]*)')
                ;;
                resolve*)
                    files=$($status $cs| _svn_grcut '@(?C*|C*)')
                ;;
                praise | blame | ann*)
                    files=$( _svn_lls all $cur* )
                ;;
                p*)
                    if [[ $cmd == @($propCmds) && $prop == @(svn:ignore|svn:externals) ]]; then
                        files=$( _svn_lls dir . $cur* );
                    else
                        files="$( _svn_lls all $cur* )
                                   $($status $cs | _svn_grcut 'A*' )";
                    fi
                ;;
                info)
                    files="$( _svn_lls all $cur* )
                               $($status $cs | _svn_grcut 'A*' )"
                ;;
                remove | rm | del* | move | mv | rename)
                    files=$( _svn_lls all $cur* )
                ;;
                mkdir)
                    files=$( _svn_lls dir $cur* )
                ;;
                log | lock | up* | cl* | switch)
                    files=$( _svn_lls all $cur* )
                ;;
                merge)
                    files=$( _svn_lls all $cur* )
                ;;
                ls | list)
                    files=$( _svn_lls all $cur* )
                ;;
                *)
                    local fallback=1
                ;;
            esac;
            if [[ $SVN_BASH_COMPL_EXT != *recurse* ]]; then
                files="$files $( _svn_lls dir $cur* )";
            fi;
            if [[ -n $files ]]; then
                COMPREPLY=($( compgen -W "$files" -- $cur ));
                [[ -n "${COMPREPLY[*]}" ]] || COMPREPLY=('');
            else
                if [[ ! -n $fallback ]]; then
                    echo -en "\a";
                    COMPREPLY=('');
                fi;
            fi;
        fi;
        return 0;
    fi;
    pOpts="--username --password --no-auth-cache --non-interactive 	       --trust-server-cert --force-interactive";
    mOpts="-m --message -F --file --encoding --force-log --with-revprop";
    rOpts="-r --revision";
    qOpts="-q --quiet";
    nOpts="-N --non-recursive --depth";
    gOpts="-g --use-merge-history";
    cOpts="--cl --changelist";
    cmdOpts=;
    case $cmd in 
        --version)
            cmdOpts="$qOpts"
        ;;
        add)
            cmdOpts="--auto-props --no-auto-props --force --targets 		         --no-ignore --parents $nOpts $qOpts $pOpts"
        ;;
        blame | annotate | ann | praise)
            cmdOpts="$rOpts $pOpts -v --verbose --incremental --xml 		         -x --extensions --force $gOpts"
        ;;
        cat)
            cmdOpts="$rOpts $pOpts"
        ;;
        changelist | cl)
            cmdOpts="--targets $pOpts $qOpts $cOpts                          -R --recursive --depth --remove"
        ;;
        checkout | co)
            cmdOpts="$rOpts $qOpts $nOpts $pOpts --ignore-externals                          --force"
        ;;
        cleanup)
            cmdOpts="--diff3-cmd $pOpts"
        ;;
        commit | ci)
            cmdOpts="$mOpts $qOpts $nOpts --targets --editor-cmd $pOpts 		         --no-unlock $cOpts --keep-changelists 		         --include-externals"
        ;;
        copy | cp)
            cmdOpts="$mOpts $rOpts $qOpts --editor-cmd $pOpts --parents 		         --ignore-externals"
        ;;
        delete | del | remove | rm)
            cmdOpts="--force $mOpts $qOpts --targets --editor-cmd $pOpts                          --keep-local"
        ;;
        diff | di)
            cmdOpts="$rOpts -x --extensions --diff-cmd --no-diff-deleted 		         $nOpts $pOpts --force --old --new --notice-ancestry 		         -c --change --summarize $cOpts --xml --git 		         --internal-diff --show-copies-as-adds 		         --ignore-properties --properties-only --no-diff-added 		         --patch-compatible"
        ;;
        export)
            cmdOpts="$rOpts $qOpts $pOpts $nOpts --force --native-eol                          --ignore-externals --ignore-keywords"
        ;;
        help | h | \?)
            cmdOpts=
        ;;
        import)
            cmdOpts="--auto-props --no-auto-props $mOpts $qOpts $nOpts 		         --no-ignore --editor-cmd $pOpts --force"
        ;;
        info)
            cmdOpts="$pOpts $rOpts --targets -R --recursive --depth                          --incremental --xml $cOpts"
        ;;
        list | ls)
            cmdOpts="$rOpts -v --verbose -R --recursive $pOpts                          --incremental --xml --depth --include-externals"
        ;;
        lock)
            cmdOpts="-m --message -F --file --encoding --force-log                          --targets --force $pOpts"
        ;;
        log)
            cmdOpts="$rOpts -v --verbose --targets $pOpts --stop-on-copy 		         --incremental --xml $qOpts -l --limit -c --change                          $gOpts --with-all-revprops --with-revprop --depth 		         --diff --diff-cmd -x --extensions --internal-diff 		         --with-no-revprops --search --search-and"
        ;;
        merge)
            cmdOpts="$rOpts $nOpts $qOpts --force --dry-run --diff3-cmd 		         $pOpts --ignore-ancestry -c --change -x --extensions                          --record-only --accept --reintegrate 		         --allow-mixed-revisions -v --verbose"
        ;;
        mergeinfo)
            cmdOpts="$rOpts $pOpts --depth --show-revs -R --recursive"
        ;;
        mkdir)
            cmdOpts="$mOpts $qOpts --editor-cmd $pOpts --parents"
        ;;
        move | mv | rename | ren)
            cmdOpts="$mOpts $rOpts $qOpts --force --editor-cmd $pOpts                          --parents --allow-mixed-revisions"
        ;;
        patch)
            cmdOpts="$qOpts $pOpts --dry-run --ignore-whitespace 			--reverse-diff --strip"
        ;;
        propdel | pdel | pd)
            cmdOpts="$qOpts -R --recursive $rOpts $pOpts $cOpts                          --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        propedit | pedit | pe)
            cmdOpts="--editor-cmd $pOpts $mOpts --force";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts"
        ;;
        propget | pget | pg)
            cmdOpts="-v --verbose -R --recursive $rOpts --strict 		         $pOpts $cOpts --depth --xml --show-inherited-props";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-v --verbose -R --recursive $rOpts --revprop $qOpts 		         $pOpts $cOpts --depth --xml --show-inherited-props"
        ;;
        propset | pset | ps)
            cmdOpts="$qOpts --targets -R --recursive 		         --encoding $pOpts --force $cOpts --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts";
            [[ -n $val ]] || cmdOpts="$cmdOpts -F --file"
        ;;
        relocate)
            cmdOpts="--ignore-externals $pOpts"
        ;;
        resolve)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --accept                          --depth"
        ;;
        resolved)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --depth"
        ;;
        revert)
            cmdOpts="--targets -R --recursive $qOpts $cOpts                          --depth $pOpts"
        ;;
        status | stat | st)
            cmdOpts="-u --show-updates -v --verbose $nOpts $qOpts $pOpts 		         --no-ignore --ignore-externals --incremental --xml                          $cOpts"
        ;;
        switch | sw)
            cmdOpts="--relocate $rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --force --accept --ignore-externals --set-depth 		         --ignore-ancestry"
        ;;
        unlock)
            cmdOpts="--targets --force $pOpts"
        ;;
        update | up)
            cmdOpts="$rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --ignore-externals --force --accept $cOpts                          --parents --editor-cmd --set-depth"
        ;;
        upgrade)
            cmdOpts="$qOpts $pOpts"
        ;;
        *)

        ;;
    esac;
    [[ "$cmd" != "--version" ]] && cmdOpts="$cmdOpts $helpOpts";
    cmdOpts="$cmdOpts --config-dir --config-option";
    if [[ $acceptOpt == @(edit|launch) ]]; then
        cmdOpts=${cmdOpts/ --non-interactive / };
    fi;
    for opt in $options;
    do
        local optBase;
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -R)
                cmdOpts=${cmdOpts/ --recursive / }
            ;;
            --recursive)
                cmdOpts=${cmdOpts/ -R / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --change / }
            ;;
            --change)
                cmdOpts=${cmdOpts/ -c / }
            ;;
            --auto-props)
                cmdOpts=${cmdOpts/ --no-auto-props / }
            ;;
            --no-auto-props)
                cmdOpts=${cmdOpts/ --auto-props / }
            ;;
            -g)
                cmdOpts=${cmdOpts/ --use-merge-history / }
            ;;
            --use-merge-history)
                cmdOpts=${cmdOpts/ -g / }
            ;;
            -m | --message | -F | --file)
                cmdOpts=${cmdOpts/ --message / };
                cmdOpts=${cmdOpts/ -m / };
                cmdOpts=${cmdOpts/ --file / };
                cmdOpts=${cmdOpts/ -F / }
            ;;
        esac;
        if [ $isHelpCmd ]; then
            cmdOpts=${cmdOpts/ -h / };
            cmdOpts=${cmdOpts/ --help / };
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svn_grcut () 
{ 
    local re=$1 line= old_IFS;
    old_IFS="$IFS";
    IFS='
';
    while read -r line; do
        [[ ! -n $re || $line == $re ]] && echo "${line/????????/}";
    done;
    IFS="$old_IFS"
}
_svn_info () 
{ 
    local what=$1 line=;
    LANG=C LC_MESSAGES=C svn info --non-interactive 2> /dev/null | while read line; do
        [[ $line == *"$what: "* ]] && echo ${line#*: };
    done
}
_svn_lls () 
{ 
    local opt=$1 f=;
    shift;
    for f in "$@";
    do
        if [[ $opt == @(dir|all) && -d "$f" ]]; then
            echo "$f/";
        else
            if [[ $opt == @(file|all) ]]; then
                local dn= fn="$f";
                [[ "$f" == */* ]] && dn=${f%\/*}/ fn=${f##*\/};
                [ -f "${dn}.svn/text-base/${fn}.svn-base" ] && echo "$f";
            fi;
        fi;
    done
}
_svn_read_hashfile () 
{ 
    local tkey=$1 key= val=;
    while true; do
        read tag len;
        [ $tag = 'END' ] && break;
        [ $tag != 'K' ] && { 
            return
        };
        read -r -n $len key;
        read;
        read tag len;
        [ $tag != 'V' ] && { 
            return
        };
        read -r -n $len val;
        read;
        if [[ $key = $tkey ]]; then
            echo "$val";
            return;
        fi;
    done
}
_svnadmin () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='crashtest create deltify dump freeze help hotcopy list-dblogs \
	      list-unused-dblogs load lock lslocks lstxns pack recover rmlocks \
	      rmtxns setlog setrevprop setuuid unlock upgrade verify --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|--parent-dir|--fs-type|-M|--memory-cache-size";
    optsParam="$optsParam|-F|--file";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        create)
            cmdOpts="--bdb-txn-nosync --bdb-log-keep --config-dir 		         --fs-type --pre-1.4-compatible --pre-1.5-compatible 		         --pre-1.6-compatible --compatible-version"
        ;;
        deltify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        dump)
            cmdOpts="-r --revision --incremental -q --quiet --deltas 		         -M --memory-cache-size"
        ;;
        freeze)
            cmdOpts="-F --file"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        hotcopy)
            cmdOpts="--clean-logs"
        ;;
        load)
            cmdOpts="--ignore-uuid --force-uuid --parent-dir -q --quiet 		         --use-pre-commit-hook --use-post-commit-hook 		         --bypass-prop-validation -M --memory-cache-size"
        ;;
        lock | unlock)
            cmdOpts="--bypass-hooks"
        ;;
        recover)
            cmdOpts="--wait"
        ;;
        rmtxns)
            cmdOpts="-q --quiet"
        ;;
        setlog)
            cmdOpts="-r --revision --bypass-hooks"
        ;;
        setrevprop)
            cmdOpts="-r --revision --use-pre-revprop-change-hook 		         --use-post-revprop-change-hook"
        ;;
        verify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -F)
                cmdOpts=${cmdOpts/ --file / }
            ;;
            --file)
                cmdOpts=${cmdOpts/ -F / }
            ;;
            -M)
                cmdOpts=${cmdOpts/ --memory-cache-size / }
            ;;
            --memory-cache-size)
                cmdOpts=${cmdOpts/ --M / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svndumpfilter () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='exclude help include --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--targets";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        exclude | include)
            cmdOpts="--drop-empty-revs --renumber-revs
		         --skip-missing-merge-sources --targets
		         --preserve-revprops --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnlook () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='author cat changed date diff dirs-changed help history info \
	      lock log propget proplist tree uuid youngest --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|-t|--transaction|-l|--limit|-x|--extensions";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        author)
            cmdOpts="-r --revision -t --transaction"
        ;;
        cat)
            cmdOpts="-r --revision -t --transaction"
        ;;
        changed)
            cmdOpts="-r --revision -t --transaction --copy-info"
        ;;
        date)
            cmdOpts="-r --revision -t --transaction"
        ;;
        diff)
            cmdOpts="-r --revision -t --transaction --diff-copy-from 		         --no-diff-added --no-diff-deleted -x --extensions"
        ;;
        dirs-changed)
            cmdOpts="-r --revision -t --transaction"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        history)
            cmdOpts="-r --revision -l --limit --show-ids"
        ;;
        info)
            cmdOpts="-r --revision -t --transaction"
        ;;
        lock)
            cmdOpts=
        ;;
        log)
            cmdOpts="-r --revision -t --transaction"
        ;;
        propget | pget | pg)
            cmdOpts="-r --revision -t --transaction --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-r --revision -t --transaction --revprop -v --verbose --xml"
        ;;
        tree)
            cmdOpts="-r --revision -t --transaction --full-paths -N --non-recursive --show-ids"
        ;;
        uuid)
            cmdOpts=
        ;;
        youngest)
            cmdOpts=
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -t)
                cmdOpts=${cmdOpts/ --transaction / }
            ;;
            --transaction)
                cmdOpts=${cmdOpts/ -t / }
            ;;
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnsync () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='copy-revprops help info initialize synchronize --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--config-dir|--config-option|--source-username|--source-password";
    optsParam="$optsParam|--sync-username|--sync-password";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        copy-revprops | initialize | init | synchronize | sync)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option -q --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        info)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnversion () 
{ 
    local cmdOpts=" -n --no-newline -c --committed -h --help --version ";
    local cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=();
    local options= wcpath= trailurl= last='none' stat= opt= i=-1 isCur=;
    for opt in ${COMP_WORDS[@]};
    do
        [[ $i -eq $COMP_CWORD ]] && stat=$last;
        let i++;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        if [ $last = 'none' ]; then
            last='first';
            continue;
        fi;
        if [[ $last != 'arg' && $opt == -* ]]; then
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='arg';
            else
                options="$options $opt ";
                last='opt';
            fi;
            continue;
        fi;
        if [[ $opt != -* ]]; then
            last='arg';
            if [[ ! -n $wcpath ]]; then
                wcpath=$opt;
            else
                if [[ ! -n $trailurl ]]; then
                    trailurl=$opt;
                fi;
            fi;
        fi;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ $cur != -* || $stat = 'arg' ]]; then
        [[ -n $wcpath && -n $trailurl ]] && COMPREPLY=('');
        return 0;
    fi;
    for opt in $options;
    do
        cmdOpts=${cmdOpts/ $opt / };
        case $opt in 
            -n)
                cmdOpts=${cmdOpts/ --no-newline / }
            ;;
            --no-newline)
                cmdOpts=${cmdOpts/ -n / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --committed / }
            ;;
            --committed)
                cmdOpts=${cmdOpts/ -c / }
            ;;
        esac;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d)
}
_terms () 
{ 
    COMPREPLY+=($( compgen -W         "$( sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap             2>/dev/null )" -- "$cur" ));
    COMPREPLY+=($( compgen -W "$( { toe -a 2>/dev/null || toe 2>/dev/null; }         | awk '{ print $1 }' | sort -u )" -- "$cur" ))
}
_tilde () 
{ 
    local result=0;
    if [[ $1 == \~* && $1 != */* ]]; then
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_ufw () 
{ 
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$(_ufw_commands)" $cur ));
    else
        if [ $COMP_CWORD -eq 2 ]; then
            case "$prev" in 
                app)
                    COMPREPLY=($( compgen -W "$(_ufw_app_commands)" $cur ))
                ;;
                status)
                    COMPREPLY=($( compgen -W "$(_ufw_status_commands)" $cur ))
                ;;
                delete)
                    COMPREPLY=($( compgen -W "$(_ufw_rule_commands)" $cur ))
                ;;
                logging)
                    COMPREPLY=($( compgen -W "$(_ufw_logging_commands)" $cur ))
                ;;
                show)
                    COMPREPLY=($( compgen -W "$(_ufw_show_commands)" $cur ))
                ;;
                default)
                    COMPREPLY=($( compgen -W "$(_ufw_default_commands)" $cur ))
                ;;
            esac;
        fi;
    fi
}
_ufw_app_commands () 
{ 
    ufw --help | sed -e '1,/^Application profile commands:/d' -e '/^ [^ ]/!d' -e 's/[ \t]\+app[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g'
}
_ufw_commands () 
{ 
    commands=$(ufw --help | sed -e '1,/^Commands:/d' -e '/^Application profile commands:/Q' -e 's/^[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g' -e 's/|/ /g' | uniq);
    echo "$commands app"
}
_ufw_default_commands () 
{ 
    echo "allow deny reject"
}
_ufw_logging_commands () 
{ 
    echo "off on low medium high full"
}
_ufw_rule_commands () 
{ 
    echo "`_ufw_default_commands` limit"
}
_ufw_show_commands () 
{ 
    echo "raw"
}
_ufw_status_commands () 
{ 
    echo "numbered verbose"
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_update_initramfs () 
{ 
    local cur prev valid_options;
    cur=$(_get_cword);
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$prev" == '-k' ]]; then
        _kernel_versions;
        COMPREPLY=($( compgen -W '${COMPREPLY[@]} all' -- "$cur" ));
        return;
    fi;
    valid_options=$( update-initramfs -h 2>&1 | 		sed -e '/^ -/!d;s/^ \(-\w\+\).*/\1/' );
    COMPREPLY=($( compgen -W "$valid_options" -- $cur ))
}
_upstart_events () 
{ 
    ( cd /etc/init && egrep --color=auto '^[[:space:]]*emits ' *.conf | cut -d: -f2- | sed 's/^[[:space:]]*emits //g' | tr ' ' '\n' | awk '{print $NF}' | grep --color=auto -v ^$ | sort -u )
}
_upstart_initctl () 
{ 
    _get_comp_words_by_ref cur prev;
    COMPREPLY=();
    case "$prev" in 
        start)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_startable_jobs)" -- ${cur}));
            return 0
        ;;
        stop)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        emit)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_events)" -- ${cur}));
            return 0
        ;;
        -i | --ignore-events)
            for cmd in check-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        -e | --enumerate)
            for cmd in show-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        reload | restart)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        status)
            COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        check-config)
            COMPREPLY=($(compgen -W "-w --warn -i --ignore-events= $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        show-config)
            COMPREPLY=($(compgen -W "-e --enumerate $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        -n | --no-wait)
            for cmd in start stop restart emit;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    case "$cmd" in 
                        start)
                            COMPREPLY=($(compgen -W "$(_upstart_startable_jobs)" -- ${cur}))
                        ;;
                        stop)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        restart)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        emit)
                            COMPREPLY=($(compgen -W "$(_upstart_events)" -- ${cur}))
                        ;;
                    esac;
                    return 0;
                fi;
            done
        ;;
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    cmds=$(initctl help|grep "^  [^ ]"|awk '{print $1}');
    COMPREPLY=($(compgen -W "${opts} ${cmds}" -- ${cur}))
}
_upstart_jobs () 
{ 
    initctl list | awk '{print $1}' | sort -u
}
_upstart_reload () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_restart () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_start () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_startable_jobs)" -- ${cur}));
    return 0
}
_upstart_startable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "stop/waiting" {print $1}'
}
_upstart_status () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q -d --detail -e --enumerate --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_jobs)" -- ${cur}));
    return 0
}
_upstart_stop () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_stoppable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "start/running" {print $1}'
}
_upvar () 
{ 
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_usergroup () 
{ 
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$( uname -s );
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == $1 ]]
}
_valgrind () 
{ 
    local cur prev opts yesno tools choosen_tool i;
    yesno="--trace-children\= --child-silent-after-fork\= --track-fds\= --time-stamp\= --log-fd\=  --log-socket\=";
    opts="--tool\= ";
    opts+="-h --help --help-debug --version -q --quiet -v --verbose --log-file\= ";
    COMPREPLY=();
    for ((i=0; i < COMP_CWORD; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == -- ]]; then
            _command_offset $((i + 1));
            return 0;
        fi;
    done;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == "--tool" ]]; then
            choosen_tool=${COMP_WORDS[i+2]};
        fi;
    done;
    case $choosen_tool in 
        'callgrind')
            opts+="--callgrind-out-file\= --dump-every-bb\= --dump-before\= --zero-before\= --dump-after\= --toggle-collect\= --separate-recs\= --separate-callers\= --fn-skip\= --fn-group< --separate-recs< --separate-callers< ";
            yesno+="--dump-instr\= --dump-line\= --compress-strings\= --compress-pos\= --combine-dumps\= --instr-atstart\= --collect-atstart\= --collect-jumps\= --separate-threads\= --skip-plt\= --simulate-cache\= --simulate-hwpref\= "
        ;;
        'cachegrind')
            opts+="--I1\= --D1\= --L2\= --cachegrind-out-file\= ";
            yesno+="--cache-sim\= --branch-sim\= "
        ;;
        'memcheck')
            yesno+="--undef-value-errors\= --track-origins\= --show-reachable\= --workaround-gcc296-bugs\= --partial-loads-ok\= ";
            opts+="--leak-check\= --leak-resolution\= --freelist-vol\= --malloc-fill\= --free-fill\= "
        ;;
        *)
            yesno+="--undef-value-errors\= --track-origins\= --show-reachable\= --workaround-gcc296-bugs\= --partial-loads-ok\= ";
            opts+="--leak-check\= --leak-resolution\= --freelist-vol\= --malloc-fill\= --free-fill\= "
        ;;
    esac;
    opts+="$yesno ";
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD - 1]}";
    if [[ "$prev" == "=" ]]; then
        prev="${COMP_WORDS[COMP_CWORD - 2]}";
    else
        if [[ "$cur" == "=" ]]; then
            cur="";
        fi;
    fi;
    if [[ "$prev" == "--tool" ]]; then
        tools="memcheck cachegrind callgrind massif helgrind lackey none drd exp-bbv exp-ptrcheck";
        COMPREPLY=($(compgen -W "$tools" -- $cur ));
        COMPREPLY+=" ";
        return 0;
    fi;
    if [[ "${yesno}" == *$prev* ]]; then
        COMPREPLY=($(compgen -W "yes no" -- $cur ));
        COMPREPLY+=" ";
        return 0;
    fi;
    case "$prev" in 
        --log-file)
            _filedir;
            return 0
        ;;
        *)

        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "$opts" -- $cur));
        return 0;
    else
        _filedir;
        return 0;
    fi
}
_variables () 
{ 
    if [[ $cur =~ ^(\$\{?)([A-Za-z0-9_]*)$ ]]; then
        [[ $cur == *{* ]] && local suffix=} || local suffix=;
        COMPREPLY+=($( compgen -P ${BASH_REMATCH[1]} -S "$suffix" -v --             "${BASH_REMATCH[2]}" ));
        return 0;
    fi;
    return 1
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || { 
        local compdir=./completions;
        [[ $BASH_SOURCE == */* ]] && compdir="${BASH_SOURCE%/*}/completions";
        . "$compdir/$srcfile"
    };
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=/etc/xinetd.d;
    if [[ -d $xinetddir ]]; then
        local restore_nullglob=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($( printf '%s\n' $xinetddir/!($_backup_glob) ));
        $restore_nullglob;
        COMPREPLY+=($( compgen -W '${svcs[@]#$xinetddir/}' -- "$cur" ));
    fi
}
command_not_found_handle () 
{ 
    if [ -x /usr/lib/command-not-found ]; then
        /usr/lib/command-not-found -- "$1";
        return $?;
    else
        if [ -x /usr/share/command-not-found/command-not-found ]; then
            /usr/share/command-not-found/command-not-found -- "$1";
            return $?;
        else
            printf "%s: command not found\n" "$1" 1>&2;
            return 127;
        fi;
    fi
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
in_array () 
{ 
    local i;
    for i in "${@:2}";
    do
        [[ $1 = "$i" ]] && return;
    done
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
